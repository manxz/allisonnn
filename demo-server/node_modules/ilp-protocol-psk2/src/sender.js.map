{"version":3,"file":"sender.js","sourceRoot":"","sources":["sender.ts"],"names":[],"mappings":";;;;;;;;;;AAAA,iCAAgC;AAChC,iCAAgC;AAChC,+BAA8B;AAC9B,+CAAoC;AACpC,wCAAuC;AACvC,yDAA0E;AAC1E,yCAAwC;AACxC,yCAAgF;AAChF,2CAAuE;AAEvE,MAAM,wBAAwB,GAAG,KAAK,CAAA;AACtC,MAAM,wBAAwB,GAAG,IAAI,CAAA;AACrC,MAAM,iBAAiB,GAAG,GAAG,CAAA;AAC7B,MAAM,iBAAiB,GAAG,GAAG,CAAA;AAG7B,IAAI,8BAA8B,GAAG,KAAK,CAAA;AA2I1C,2BAAyC,MAA2B,EAAE,MAAyB;;QAC7F,IAAI,EACF,YAAY,EACZ,YAAY,EACZ,kBAAkB,EAClB,EAAE,GAAG,MAAM,CAAC,WAAW,CAAC,EAAE,CAAC,EAC5B,GAAG,MAAM,CAAA;QACV,YAAY,GAAG,IAAI,sBAAS,CAAC,YAAY,CAAC,CAAA;QAC1C,MAAM,CAAC,YAAY,CAAC,SAAS,EAAE,EAAE,iCAAiC,CAAC,CAAA;QACnE,MAAM,CAAC,YAAY,EAAE,0BAA0B,CAAC,CAAA;QAChD,MAAM,CAAC,YAAY,CAAC,MAAM,IAAI,EAAE,EAAE,wCAAwC,CAAC,CAAA;QAE3E,MAAM,CAAC,kBAAkB,IAAI,OAAO,kBAAkB,KAAK,QAAQ,EAAE,gCAAgC,CAAC,CAAA;QACtG,MAAM,CAAC,CAAC,MAAM,CAAC,QAAQ,CAAC,EAAE,CAAC,IAAI,EAAE,CAAC,MAAM,KAAK,EAAE,CAAC,EAAE,6BAA6B,CAAC,CAAA;QAChF,MAAM,CAAC,KAAK,CAAC,MAAM,EAAE,YAAY,EAAE,EAAE,EAAE,kBAAkB,EAAE,YAAY,EAAE,SAAS,CAAC,CAAA;IACrF,CAAC;CAAA;AAfD,8CAeC;AAWD,gCAA8C,MAA2B,EAAE,MAA8B;;QACvG,IAAI,EACF,iBAAiB,EACjB,YAAY,EACZ,kBAAkB,EAClB,EAAE,GAAG,MAAM,CAAC,WAAW,CAAC,EAAE,CAAC,EAC5B,GAAG,MAAM,CAAA;QACV,iBAAiB,GAAG,IAAI,sBAAS,CAAC,iBAAiB,CAAC,CAAA;QACpD,MAAM,CAAC,iBAAiB,CAAC,SAAS,EAAE,EAAE,sCAAsC,CAAC,CAAA;QAC7E,MAAM,CAAC,YAAY,EAAE,0BAA0B,CAAC,CAAA;QAChD,MAAM,CAAC,YAAY,CAAC,MAAM,IAAI,EAAE,EAAE,wCAAwC,CAAC,CAAA;QAE3E,MAAM,CAAC,kBAAkB,IAAI,OAAO,kBAAkB,KAAK,QAAQ,EAAE,gCAAgC,CAAC,CAAA;QACtG,MAAM,CAAC,CAAC,MAAM,CAAC,QAAQ,CAAC,EAAE,CAAC,IAAI,EAAE,CAAC,MAAM,KAAK,EAAE,CAAC,EAAE,yCAAyC,CAAC,CAAA;QAC5F,MAAM,CAAC,KAAK,CAAC,MAAM,EAAE,YAAY,EAAE,EAAE,EAAE,kBAAkB,EAAE,SAAS,EAAE,iBAAiB,CAAC,CAAA;IAC1F,CAAC;CAAA;AAfD,wDAeC;AAED,eACE,MAA2B,EAC3B,YAAoB,EACpB,EAAU,EACV,kBAA0B,EAC1B,YAAwB,EACxB,iBAA6B;;QAE7B,MAAM,GAAG,2BAAO,CAAC,MAAM,CAAC,CAAA;QACxB,MAAM,KAAK,GAAG,KAAK,CAAC,yBAAyB,CAAC,CAAA;QAE9C,MAAM,QAAQ,GAAG,CAAC,CAAA;QAClB,MAAM,IAAI,GAAG,6BAAkB,CAC7B,YAAY,EAAE;YAEZ,IAAI,EAAE,SAAS,CAAC,oBAAoB;YACpC,SAAS,EAAE,EAAE;YACb,QAAQ;YACR,aAAa,EAAE,SAAS,CAAC,UAAU;YAInC,WAAW,EAAE,SAAS,CAAC,UAAU;SAClC,CAAC,CAAA;QACJ,MAAM,MAAM,GAAG,IAAI,sBAAS,CAAC,YAAY,IAAI,wBAAwB,CAAC,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAA;QACnF,MAAM,GAAG,GAAG,SAAS,CAAC,mBAAmB,CAAC;YACxC,WAAW,EAAE,kBAAkB;YAC/B,MAAM;YACN,kBAAkB,EAAE,MAAM,CAAC,WAAW,CAAC,EAAE,CAAC;YAC1C,SAAS,EAAE,IAAI,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,wBAAwB,CAAC;YAC1D,IAAI;SACL,CAAC,CAAA;QAEF,IAAI,aAAa,GAAG,IAAI,sBAAS,CAAC,CAAC,CAAC,CAAA;QACpC,MAAM,MAAM,GAAG,MAAM,MAAM,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAA;QACzC,IAAI,SAAS,CAAA;QACb,IAAI,CAAC;YACH,SAAS,GAAG,SAAS,CAAC,oBAAoB,CAAC,MAAM,CAAC,CAAA;YAClD,MAAM,CAAC,SAAS,CAAC,IAAI,KAAK,KAAK,EAAE,8BAA8B,SAAS,CAAC,IAAI,IAAI,SAAS,CAAC,OAAO,EAAE,CAAC,CAAA;YACrG,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,EAAE,yBAAyB,CAAC,CAAA;QAC9D,CAAC;QAAC,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;YACb,KAAK,CAAC,qCAAqC,EAAE,GAAG,CAAC,CAAA;YACjD,MAAM,IAAI,KAAK,CAAC,uBAAuB,GAAG,GAAG,CAAC,OAAO,CAAC,CAAA;QACxD,CAAC;QAED,IAAI,CAAC;YACH,MAAM,aAAa,GAAG,+BAAoB,CAAC,YAAY,EAAE,SAAS,CAAC,IAAI,CAAC,CAAA;YAGxE,MAAM,CAAC,aAAa,CAAC,IAAI,KAAK,SAAS,CAAC,eAAe,EAAE,6BAA6B,CAAC,CAAA;YACvF,MAAM,CAAC,EAAE,CAAC,MAAM,CAAC,aAAa,CAAC,SAAS,CAAC,EAAE,mDAAmD,CAAC,CAAA;YAC/F,MAAM,CAAC,QAAQ,KAAK,aAAa,CAAC,QAAQ,EAAE,wCAAwC,CAAC,CAAA;YAErF,aAAa,GAAG,aAAa,CAAC,WAAW,CAAA;QAC3C,CAAC;QAAC,KAAK,CAAC,CAAC,aAAa,CAAC,CAAC,CAAC;YACvB,KAAK,CAAC,wCAAwC,EAAE,aAAa,EAAE,MAAM,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC,CAAA;YACzF,MAAM,IAAI,KAAK,CAAC,gCAAgC,CAAC,CAAA;QACnD,CAAC;QAED,KAAK,CAAC,iBAAiB,aAAa,CAAC,QAAQ,CAAC,EAAE,CAAC,sBAAsB,MAAM,WAAW,aAAa,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,QAAQ,CAAC,EAAE,CAAC,GAAG,CAAC,CAAA;QAClI,IAAI,kBAAkB,CAAA;QACtB,IAAI,uBAAuB,CAAA;QAC3B,EAAE,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC;YACjB,kBAAkB,GAAG,IAAI,sBAAS,CAAC,YAAY,CAAC,CAAA;YAChD,uBAAuB,GAAG,aAAa,CAAA;QACzC,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,kBAAkB,GAAG,IAAI,sBAAS,CAAC,iBAA8B,CAAC;iBAC/D,GAAG,CAAC,aAAa,CAAC;iBAClB,KAAK,CAAC,wBAAwB,CAAC;iBAC/B,KAAK,CAAC,CAAC,EAAE,sBAAS,CAAC,QAAQ,CAAC,CAAA;YAE/B,uBAAuB,GAAG,IAAI,sBAAS,CAAC,iBAA8B,CAAC,CAAA;QACzE,CAAC;QACD,MAAM,CAAC;YACL,YAAY,EAAE,kBAAkB,CAAC,QAAQ,CAAC,EAAE,CAAC;YAC7C,iBAAiB,EAAE,uBAAuB,CAAC,QAAQ,CAAC,EAAE,CAAC;SACxD,CAAA;IACH,CAAC;CAAA;AA+DD,yBAAuC,MAAW,EAAE,MAA6D;;QAC/G,MAAM,GAAG,2BAAO,CAAC,MAAM,CAAC,CAAA;QACxB,MAAM,KAAK,GAAG,KAAK,CAAC,mCAAmC,CAAC,CAAA;QACxD,MAAM,EACJ,YAAY,EACZ,YAAY,EACZ,kBAAkB,EAClB,oBAAoB,GAAG,CAAC,EACzB,GAAG,MAAM,CAAA;QAEV,oBAAqB,MAA6D;YAEhF,MAAM,CAAE,MAAwC,CAAC,EAAE,KAAK,SAAS,CAAA;QACnE,CAAC;QACD,MAAM,EACJ,EAAE,EACF,QAAQ,EACR,SAAS,EACV,GAAG,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;YAEjC,EAAE,EAAE,MAAM,CAAC,WAAW,CAAC,EAAE,CAAC;YAC1B,QAAQ,EAAE,CAAC;YACX,SAAS,EAAE,IAAI;SAChB,CAAC,CAAA;QAEF,MAAM,CAAC,YAAY,EAAE,0BAA0B,CAAC,CAAA;QAChD,MAAM,CAAC,YAAY,CAAC,MAAM,IAAI,EAAE,EAAE,wCAAwC,CAAC,CAAA;QAC3E,MAAM,CAAC,YAAY,EAAE,0BAA0B,CAAC,CAAA;QAChD,MAAM,CAAC,CAAC,EAAE,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,EAAE,CAAC,IAAI,EAAE,CAAC,MAAM,KAAK,EAAE,CAAC,EAAE,yCAAyC,CAAC,CAAA;QAEnG,KAAK,CAAC,gCAAgC,EAAE,CAAC,QAAQ,CAAC,KAAK,CAAC,wBAAwB,YAAY,oCAAoC,oBAAoB,EAAE,CAAC,CAAA;QAEvJ,MAAM,IAAI,GAAG,6BAAkB,CAAC,YAAY,EAAE;YAC5C,IAAI,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC,SAAS,CAAC,oBAAoB,CAAC,CAAC,CAAC,SAAS,CAAC,eAAe,CAAC;YAC9E,SAAS,EAAE,EAAE;YACb,QAAQ;YAIR,aAAa,EAAE,SAAS,CAAC,UAAU;YACnC,WAAW,EAAE,IAAI,sBAAS,CAAC,oBAAoB,CAAC;SACjD,CAAC,CAAA;QACF,MAAM,WAAW,GAAG,6BAAiB,CAAC,YAAY,EAAE,IAAI,CAAC,CAAA;QACzD,MAAM,kBAAkB,GAAG,kCAAsB,CAAC,WAAW,CAAC,CAAA;QAC9D,MAAM,GAAG,GAAG,SAAS,CAAC,mBAAmB,CAAC;YACxC,WAAW,EAAE,kBAAkB;YAC/B,MAAM,EAAE,IAAI,sBAAS,CAAC,YAAY,CAAC,CAAC,QAAQ,CAAC,EAAE,CAAC;YAChD,kBAAkB;YAClB,SAAS,EAAE,IAAI,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,wBAAwB,CAAC;YAC1D,IAAI;SACL,CAAC,CAAA;QAEF,MAAM,MAAM,GAAG,MAAM,MAAM,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAA;QAEzC,IAAI,MAAM,CAAA;QACV,IAAI,CAAC;YACH,MAAM,GAAG,SAAS,CAAC,oBAAoB,CAAC,MAAM,CAAC,CAAA;QACjD,CAAC;QAAC,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;YACb,KAAK,CAAC,kCAAkC,EAAE,GAAG,EAAE,WAAW,EAAE,MAAM,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC,CAAA;YACtF,MAAM,GAAG,CAAA;QACX,CAAC;QAED,IAAI,eAAqC,CAAA;QACzC,EAAE,CAAC,CAAC,MAAM,CAAC,IAAI,KAAK,SAAS,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC,CAAC;YAEpD,eAAe,GAAG,MAAM,CAAC,IAA4B,CAAA;QACvD,CAAC;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,MAAM,CAAC,IAAI,KAAK,SAAS,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC,CAAC;YAE1D,MAAM,SAAS,GAA2B,MAAM,CAAC,IAA8B,CAAA;YAG/E,KAAK,CAAC,wBAAwB,EAAE,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC,CAAA;YAC1D,MAAM,IAAI,KAAK,CAAC,gCAAgC,SAAS,CAAC,IAAI,cAAc,SAAS,CAAC,OAAO,GAAG,CAAC,CAAA;QACnG,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,KAAK,CAAC,2CAA2C,EAAE,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,CAAA;YAC1E,MAAM,IAAI,KAAK,CAAC,yCAAyC,GAAG,MAAM,CAAC,IAAI,CAAC,CAAA;QAC1E,CAAC;QAED,EAAE,CAAC,CAAC,CAAC,WAAW,CAAC,MAAM,CAAC,eAAe,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;YACrD,KAAK,CAAC,2CAA2C,WAAW,CAAC,QAAQ,CAAC,QAAQ,CAAC,aAAa,eAAe,CAAC,WAAW,CAAC,QAAQ,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAA;YAC7I,MAAM,IAAI,KAAK,CAAC,2CAA2C,WAAW,CAAC,QAAQ,CAAC,QAAQ,CAAC,aAAa,eAAe,CAAC,WAAW,CAAC,QAAQ,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAA;QACzJ,CAAC;QAED,IAAI,aAAa,CAAA;QACjB,IAAI,CAAC;YACH,MAAM,QAAQ,GAAG,+BAAoB,CAAC,YAAY,EAAE,eAAe,CAAC,IAAI,CAAC,CAAA;YAEzE,MAAM,CAAC,SAAS,CAAC,qBAAqB,KAAK,QAAQ,CAAC,IAAI,EAAE,yCAAyC,SAAS,CAAC,qBAAqB,aAAa,QAAQ,CAAC,IAAI,EAAE,CAAC,CAAA;YAC/J,MAAM,CAAC,EAAE,CAAC,MAAM,CAAC,QAAQ,CAAC,SAAS,CAAC,EAAE,+EAA+E,QAAQ,CAAC,SAAS,CAAC,QAAQ,CAAC,KAAK,CAAC,eAAe,EAAE,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE,CAAC,CAAA;YAC3L,MAAM,CAAC,QAAQ,KAAK,QAAQ,CAAC,QAAQ,EAAE,6EAA6E,QAAQ,CAAC,QAAQ,eAAe,QAAQ,EAAE,CAAC,CAAA;YAE/J,aAAa,GAAG,QAAQ,CAAC,WAAW,CAAA;QACtC,CAAC;QAAC,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;YACb,KAAK,CAAC,uBAAuB,EAAE,GAAG,EAAE,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,CAAA;YAC3D,MAAM,IAAI,KAAK,CAAC,kCAAkC,GAAG,GAAG,CAAC,OAAO,CAAC,CAAA;QACnE,CAAC;QAED,KAAK,CAAC,6BAA6B,EAAE,CAAC,QAAQ,CAAC,KAAK,CAAC,wBAAwB,YAAY,yBAAyB,aAAa,CAAC,QAAQ,CAAC,EAAE,CAAC,EAAE,CAAC,CAAA;QAE/I,MAAM,CAAC;YAEL,EAAE;YACF,YAAY,EAAE,IAAI,sBAAS,CAAC,YAAY,CAAC,CAAC,QAAQ,CAAC,EAAE,CAAC;YACtD,iBAAiB,EAAE,aAAa,CAAC,QAAQ,CAAC,EAAE,CAAC;YAC7C,eAAe,EAAE,CAAC;YAClB,cAAc,EAAE,CAAC;SAClB,CAAA;IACH,CAAC;CAAA;AA3GD,0CA2GC;AASD,0BAAwC,MAAW,EAAE,MAAwB;;QAC3E,MAAM,CAAC,MAAM,CAAC,YAAY,EAAE,0BAA0B,CAAC,CAAA;QACvD,MAAM,CAAC,kBAAkB,CAAC,MAAM,EAAE,MAAM,CAAC,CAAA;IAC3C,CAAC;CAAA;AAHD,4CAGC;AASD,+BAA6C,MAAW,EAAE,MAA6B;;QAErF,MAAM,CAAC,MAAM,CAAC,iBAAiB,EAAE,+BAA+B,CAAC,CAAA;QACjE,MAAM,CAAC,kBAAkB,CAAC,MAAM,EAAE,MAAM,CAAC,CAAA;IAC3C,CAAC;CAAA;AAJD,sDAIC;AAUD,4BAAmC,MAAW,EAAE,MAA4B;;QAC1E,MAAM,EACJ,YAAY,EACZ,kBAAkB,EAClB,YAAY,EACZ,iBAAiB,EACjB,EAAE,GAAG,MAAM,CAAC,WAAW,CAAC,EAAE,CAAC,EAC5B,GAAG,MAAM,CAAA;QACV,MAAM,CAAC,YAAY,EAAE,0BAA0B,CAAC,CAAA;QAChD,MAAM,CAAC,YAAY,CAAC,MAAM,IAAI,EAAE,EAAE,wCAAwC,CAAC,CAAA;QAC3E,MAAM,CAAC,kBAAkB,EAAE,gCAAgC,CAAC,CAAA;QAC5D,MAAM,CAAC,CAAC,MAAM,CAAC,QAAQ,CAAC,EAAE,CAAC,IAAI,EAAE,CAAC,MAAM,KAAK,EAAE,CAAC,EAAE,yCAAyC,CAAC,CAAA;QAC5F,MAAM,GAAG,2BAAO,CAAC,MAAM,CAAC,CAAA;QACxB,MAAM,KAAK,GAAG,KAAK,CAAC,kCAAkC,CAAC,CAAA;QAEvD,EAAE,CAAC,CAAC,CAAC,8BAA8B,CAAC,CAAC,CAAC;YACpC,OAAO,CAAC,IAAI,CAAC,2PAA2P,CAAC,CAAA;YACzQ,8BAA8B,GAAG,IAAI,CAAA;QACvC,CAAC;QAED,IAAI,UAAU,GAAG,IAAI,sBAAS,CAAC,CAAC,CAAC,CAAA;QACjC,IAAI,eAAe,GAAG,IAAI,sBAAS,CAAC,CAAC,CAAC,CAAA;QACtC,IAAI,QAAQ,GAAG,CAAC,CAAA;QAChB,IAAI,SAAS,GAAG,IAAI,sBAAS,CAAC,wBAAwB,CAAC,CAAA;QACvD,IAAI,SAAS,GAAG,KAAK,CAAA;QACrB,IAAI,UAAU,GAAG,CAAC,CAAA;QAClB,IAAI,IAAI,GAAG,IAAI,sBAAS,CAAC,CAAC,CAAC,CAAA;QAC3B,IAAI,eAAe,GAAG,CAAC,CAAA;QACvB,IAAI,cAAc,GAAG,CAAC,CAAA;QAEtB,gCAAiC,SAAiB,EAAE,YAAoB,EAAE,gBAAwB;YAChG,IAAI,CAAC;gBACH,MAAM,QAAQ,GAAG,+BAAoB,CAAC,YAAY,EAAE,SAAS,CAAC,CAAA;gBAE9D,MAAM,CAAC,YAAY,KAAK,QAAQ,CAAC,IAAI,EAAE,qCAAqC,YAAY,aAAa,QAAQ,CAAC,IAAI,EAAE,CAAC,CAAA;gBACrH,MAAM,CAAC,EAAE,CAAC,MAAM,CAAC,QAAQ,CAAC,SAAS,CAAC,EAAE,+EAA+E,QAAQ,CAAC,SAAS,CAAC,QAAQ,CAAC,KAAK,CAAC,eAAe,EAAE,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE,CAAC,CAAA;gBAC3L,MAAM,CAAC,gBAAgB,KAAK,QAAQ,CAAC,QAAQ,EAAE,6EAA6E,QAAQ,CAAC,QAAQ,eAAe,QAAQ,GAAG,CAAC,EAAE,CAAC,CAAA;gBAE3K,MAAM,cAAc,GAAG,QAAQ,CAAC,aAAa,CAAA;gBAC7C,KAAK,CAAC,qCAAqC,cAAc,CAAC,QAAQ,CAAC,EAAE,CAAC,EAAE,CAAC,CAAA;gBACzE,EAAE,CAAC,CAAC,cAAc,CAAC,GAAG,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC;oBACxC,eAAe,GAAG,cAAc,CAAA;oBAChC,IAAI,GAAG,eAAe,CAAC,GAAG,CAAC,UAAU,CAAC,CAAA;gBACxC,CAAC;gBAAC,IAAI,CAAC,CAAC;oBAEN,KAAK,CAAC,qEAAqE,eAAe,CAAC,QAAQ,CAAC,EAAE,CAAC,UAAU,cAAc,CAAC,QAAQ,CAAC,EAAE,CAAC,EAAE,CAAC,CAAA;gBACjJ,CAAC;YACH,CAAC;YAAC,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;gBACb,KAAK,CAAC,iCAAiC,EAAE,GAAG,EAAE,SAAS,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC,CAAA;gBAC3E,MAAM,IAAI,KAAK,CAAC,kCAAkC,GAAG,GAAG,CAAC,OAAO,CAAC,CAAA;YACnE,CAAC;QACH,CAAC;QAED,OAAO,IAAI,EAAE,CAAC;YAEZ,IAAI,gBAAgB,CAAA;YACpB,EAAE,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC;gBAEjB,gBAAgB,GAAG,IAAI,sBAAS,CAAC,YAAY,CAAC,CAAC,KAAK,CAAC,UAAU,CAAC,CAAA;gBAChE,KAAK,CAAC,wBAAwB,gBAAgB,CAAC,QAAQ,CAAC,EAAE,CAAC,EAAE,CAAC,CAAA;YAChE,CAAC;YAAC,IAAI,CAAC,CAAC;gBAEN,MAAM,mBAAmB,GAAG,IAAI,sBAAS,CAAC,iBAAiB,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,eAAe,CAAC,CAAA;gBACxF,EAAE,CAAC,CAAC,mBAAmB,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;oBAC/B,KAAK,CAAC,2BAA2B,CAAC,CAAA;oBAClC,KAAK,CAAA;gBACP,CAAC;gBAED,EAAE,CAAC,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;oBACrB,MAAM,IAAI,GAAG,eAAe,CAAC,GAAG,CAAC,UAAU,CAAC,CAAA;oBAC5C,gBAAgB,GAAG,mBAAmB,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,sBAAS,CAAC,UAAU,CAAC,CAAA;oBAC/E,KAAK,CAAC,wBAAwB,gBAAgB,CAAC,QAAQ,CAAC,EAAE,CAAC,6BAA6B,mBAAmB,CAAC,QAAQ,CAAC,EAAE,CAAC,WAAW,IAAI,CAAC,QAAQ,CAAC,EAAE,CAAC,GAAG,CAAC,CAAA;gBAC1J,CAAC;gBAAC,IAAI,CAAC,CAAC;oBAEN,gBAAgB,GAAG,SAAS,CAAC,UAAU,CAAA;oBACvC,KAAK,CAAC,8BAA8B,CAAC,CAAA;gBACvC,CAAC;YACH,CAAC;YAGD,EAAE,CAAC,CAAC,gBAAgB,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;gBAC5B,KAAK,CAAA;YACP,CAAC;YAGD,EAAE,CAAC,CAAC,gBAAgB,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;gBACpC,KAAK,CAAC,oBAAoB,CAAC,CAAA;gBAC3B,SAAS,GAAG,gBAAgB,CAAA;gBAC5B,SAAS,GAAG,IAAI,CAAA;YAClB,CAAC;YAGD,MAAM,iCAAiC,GAAG,sBAAS,CAAC,GAAG,CACrD,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,sBAAS,CAAC,UAAU,CAAC,EACpD,SAAS,CAAC,UAAU,CAAC,CAAA;YAEvB,MAAM,IAAI,GAAG,6BAAkB,CAAC,YAAY,EAAE;gBAC5C,IAAI,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC,SAAS,CAAC,oBAAoB,CAAC,CAAC,CAAC,SAAS,CAAC,eAAe,CAAC;gBAC9E,SAAS,EAAE,EAAE;gBACb,QAAQ;gBACR,aAAa,EAAE,CAAC,iBAAiB,CAAC,CAAC,CAAC,IAAI,sBAAS,CAAC,iBAAiB,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,UAAU,CAAC;gBAC5F,WAAW,EAAE,iCAAiC;aAC/C,CAAC,CAAA;YACF,MAAM,WAAW,GAAG,6BAAiB,CAAC,YAAY,EAAE,IAAI,CAAC,CAAA;YACzD,MAAM,kBAAkB,GAAG,kCAAsB,CAAC,WAAW,CAAC,CAAA;YAC9D,MAAM,OAAO,GAAG,SAAS,CAAC,mBAAmB,CAAC;gBAC5C,WAAW,EAAE,kBAAkB;gBAC/B,MAAM,EAAE,SAAS,CAAC,QAAQ,CAAC,EAAE,CAAC;gBAC9B,SAAS,EAAE,IAAI,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,wBAAwB,CAAC;gBAC1D,kBAAkB;gBAClB,IAAI;aACL,CAAC,CAAA;YAEF,MAAM,MAAM,GAAG,MAAM,MAAM,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAA;YAE7C,IAAI,MAAM,CAAA;YACV,IAAI,CAAC;gBACH,MAAM,GAAG,SAAS,CAAC,oBAAoB,CAAC,MAAM,CAAC,CAAA;YACjD,CAAC;YAAC,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;gBACb,KAAK,CAAC,kCAAkC,EAAE,GAAG,EAAE,WAAW,EAAE,MAAM,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC,CAAA;gBACtF,MAAM,GAAG,CAAA;YACX,CAAC;YAED,EAAE,CAAC,CAAC,MAAM,CAAC,IAAI,KAAK,SAAS,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC,CAAC;gBAEpD,MAAM,OAAO,GAAG,MAAM,CAAC,IAA4B,CAAA;gBAEnD,EAAE,CAAC,CAAC,CAAC,WAAW,CAAC,MAAM,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;oBAC7C,KAAK,CAAC,2CAA2C,WAAW,CAAC,QAAQ,CAAC,QAAQ,CAAC,aAAa,OAAO,CAAC,WAAW,CAAC,QAAQ,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAA;oBACrI,MAAM,IAAI,KAAK,CAAC,2CAA2C,WAAW,CAAC,QAAQ,CAAC,QAAQ,CAAC,aAAa,OAAO,CAAC,WAAW,CAAC,QAAQ,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAA;gBACjJ,CAAC;gBAED,UAAU,GAAG,UAAU,CAAC,IAAI,CAAC,SAAS,CAAC,CAAA;gBACvC,sBAAsB,CAAC,OAAO,CAAC,IAAI,EAAE,SAAS,CAAC,qBAAqB,EAAE,QAAQ,CAAC,CAAA;gBAE/E,eAAe,IAAI,CAAC,CAAA;gBACpB,SAAS,GAAG,SAAS,CAAC,KAAK,CAAC,iBAAiB,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAA;gBACvD,KAAK,CAAC,oDAAoD,EAAE,SAAS,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,CAAA;gBACnF,UAAU,GAAG,CAAC,CAAA;gBAEd,EAAE,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC;oBACd,KAAK,CAAA;gBACP,CAAC;gBAAC,IAAI,CAAC,CAAC;oBACN,QAAQ,EAAE,CAAA;gBACZ,CAAC;YACH,CAAC;YAAC,IAAI,CAAC,EAAE,CAAC,CAAC,MAAM,CAAC,IAAI,KAAK,SAAS,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC,CAAC;gBAE1D,MAAM,SAAS,GAAG,MAAM,CAAC,IAA8B,CAAA;gBACvD,EAAE,CAAC,CAAC,SAAS,CAAC,IAAI,KAAK,KAAK,CAAC,CAAC,CAAC;oBAE7B,sBAAsB,CACpB,SAAS,CAAC,IAAI,EACd,SAAS,CAAC,eAAe,EACzB,QAAQ,CAAC,CAAA;gBACb,CAAC;gBAAC,IAAI,CAAC,EAAE,CAAC,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,GAAG,IAAI,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC;oBAIlE,SAAS,GAAG,SAAS;yBAClB,KAAK,CAAC,iBAAiB,CAAC;yBACxB,KAAK,CAAC,CAAC,CAAC,CAAA;oBACX,EAAE,CAAC,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;wBACpB,SAAS,GAAG,IAAI,sBAAS,CAAC,CAAC,CAAC,CAAA;oBAC9B,CAAC;oBACD,UAAU,GAAG,IAAI,CAAC,GAAG,CAAC,UAAU,GAAG,CAAC,EAAE,GAAG,CAAC,CAAA;oBAC1C,KAAK,CAAC,gCAAgC,SAAS,CAAC,IAAI,6BAA6B,SAAS,CAAC,QAAQ,CAAC,EAAE,CAAC,iBAAiB,UAAU,IAAI,CAAC,CAAA;oBACvI,MAAM,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE,CAAC,UAAU,CAAC,OAAO,EAAE,UAAU,CAAC,CAAC,CAAA;gBACzE,CAAC;gBAAC,IAAI,CAAC,CAAC;oBAEN,KAAK,CAAC,qCAAqC,EAAE,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC,CAAA;oBACvE,MAAM,IAAI,KAAK,CAAC,uCAAuC,SAAS,CAAC,IAAI,GAAG,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,GAAG,SAAS,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAA;gBAChI,CAAC;YACH,CAAC;YAAC,IAAI,CAAC,CAAC;gBACN,KAAK,CAAC,2CAA2C,EAAE,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,CAAA;gBAC1E,MAAM,IAAI,KAAK,CAAC,yCAAyC,GAAG,MAAM,CAAC,IAAI,CAAC,CAAA;YAC1E,CAAC;QACH,CAAC;QAED,KAAK,CAAC,gCAAgC,UAAU,CAAC,QAAQ,CAAC,EAAE,CAAC,yBAAyB,eAAe,CAAC,QAAQ,CAAC,EAAE,CAAC,uBAAuB,QAAQ,GAAG,CAAC,EAAE,CAAC,CAAA;QAExJ,MAAM,CAAC;YACL,EAAE;YACF,YAAY,EAAE,UAAU,CAAC,QAAQ,CAAC,EAAE,CAAC;YACrC,iBAAiB,EAAE,eAAe,CAAC,QAAQ,CAAC,EAAE,CAAC;YAC/C,eAAe;YACf,cAAc;SACf,CAAA;IACH,CAAC;CAAA","sourcesContent":["import * as assert from 'assert'\nimport * as crypto from 'crypto'\nimport * as Debug from 'debug'\nimport BigNumber from 'bignumber.js'\nimport * as IlpPacket from 'ilp-packet'\nimport { default as convert, PluginV1, PluginV2 } from 'ilp-compat-plugin'\nimport * as constants from './constants'\nimport { serializePskPacket, deserializePskPacket, PskPacket } from './encoding'\nimport { dataToFulfillment, fulfillmentToCondition } from './condition'\n\nconst DEFAULT_TRANSFER_TIMEOUT = 30000\nconst STARTING_TRANSFER_AMOUNT = 1000\nconst TRANSFER_INCREASE = 1.1\nconst TRANSFER_DECREASE = 0.5\n\n// Chunked payments are still experimental so we want to warn the user (but only once per use of the module)\nlet warnedUserAboutChunkedPayments = false\n\n/** Parameters for the [`quoteSourceAmount`]{@link quoteSourceAmount} method. */\nexport interface QuoteSourceParams {\n  /**\n   * Integer amount indicating how much the sender would like to send.\n   *\n   * **Note:** The `quoteSourceAmount` method will send an unfulfillable test payment of this amount to the Receiver to determine the path exchange rate.\n   */\n  sourceAmount: BigNumber | string | number,\n  /** Shared secret from the Receiver (generated with the [`generateAddressAndSecret`]{@link Receiver.generateAddressAndSecret} method). */\n  sharedSecret: Buffer,\n  /** Destination account of the Receiver (generated with the [`generateAddressAndSecret`]{@link Receiver.generateAddressAndSecret} method). */\n  destinationAccount: string,\n  /** Optional ID that will be used as the PSK Payment ID. A random one will be used if none is provided. */\n  id?: Buffer\n}\n\n/** Parameters for the [`quoteDestinationAmount`]{@link quoteDestinationAmount} method. */\nexport interface QuoteDestinationParams {\n  /**\n   * Integer amount indicating how much the sender would like to deliver to the Receiver, denoted in the Receiver's units.\n   *\n   * **Note:** The `quoteDestinationAmount` method will send an unfulfillable test payment of 1000 source units to the Receiver to determine the path exchange rate.\n   */\n  destinationAmount: BigNumber | string | number,\n  /** Shared secret from the Receiver (generated with the [`generateAddressAndSecret`]{@link Receiver.generateAddressAndSecret} method). */\n  sharedSecret: Buffer,\n  /** Destination account of the Receiver (generated with the [`generateAddressAndSecret`]{@link Receiver.generateAddressAndSecret} method). */\n  destinationAccount: string,\n  /** Optional ID that will be used as the PSK Payment ID. A random one will be used if none is provided. */\n  id?: Buffer\n}\n\n/** Quote result from either the [`quoteSourceAmount`]{@link quoteSourceAmount} or [`quoteDestinationAmount`]{@link quoteDestinationAmount} methods. */\nexport interface QuoteResult {\n  /** Integer amount indicating approximately how much the sender must send in order to deliver the given destination amount to the Receiver. */\n  sourceAmount: string,\n  /** Integer amount indicating approximately how much will be delivered to the Receiver if the sender sends the given destination amoutn. Denominated in the Receiver's units. */\n  destinationAmount: string\n}\n\n/** Parameters for the [`sendSingleChunk`]{@link sendSingleChunk} method to send a one-off payment. */\nexport interface SendSingleChunkParams {\n  /** Integer amount indicating how much should be sent. Denoted in the sender's units. */\n  sourceAmount: BigNumber | string | number,\n  /** Shared secret from the Receiver (generated with the [`generateAddressAndSecret`]{@link Receiver.generateAddressAndSecret} method). */\n  sharedSecret: Buffer,\n  /** Destination account of the Receiver (generated with the [`generateAddressAndSecret`]{@link Receiver.generateAddressAndSecret} method). */\n  destinationAccount: string,\n  /**\n   * Minimum amount that the Receiver should get in order for them to fulfill the payment. Defaults to `0`.\n   *\n   * If the sender gets a quote before sending, they SHOULD set this value to the destination amount they expect will be delivered.\n   * A `0`-amount means that the Receiver will fulfill the payment even if the connectors charge unreasonably high fees.\n   */\n  minDestinationAmount?: BigNumber | string | number,\n}\n\n/** Parameters for the [`sendSingleChunk`]{@link sendSingleChunk} method that give the user more control and may be used for streaming payments. */\nexport interface SendSingleChunkAdvancedParams {\n  /** See [SendSingleChunkParams]{@link SendSingleChunkParams} */\n  sourceAmount: BigNumber | string | number,\n  /** See [SendSingleChunkParams]{@link SendSingleChunkParams} */\n  sharedSecret: Buffer,\n  /** See [SendSingleChunkParams]{@link SendSingleChunkParams} */\n  destinationAccount: string\n  /** See [SendSingleChunkParams]{@link SendSingleChunkParams} */\n  minDestinationAmount?: BigNumber | string | number,\n  /**\n   * Optional ID that will be used as the PSK Payment ID and that the Receiver will use to group payment chunks. Defaults to a random 16-byte ID.\n   *\n   * This value must be set if the sender wants the Receiver to associate multiple payment chunks with one payment or interaction.\n   *\n   * If this value is set, the user MUST increment the `sequence` number for each chunk fulfilled.\n   */\n  id: Buffer,\n  /**\n   * Sequence number for the chunk within a larger payment. Defaults to `0`.\n   *\n   * If the `id` is set, this value MUST be incremented for each chunk fulfilled.\n   */\n  sequence: number,\n  /**\n   * Indicates to the Receiver whether this is the last chunk of the given payment `id`. Defaults to `true`.\n   *\n   * Once the Receiver has received a chunk with the last chunk flag set, they will no longer accept more chunks\n   */\n  lastChunk: boolean\n}\n\n/** Return value from [`sendSingleChunk`]{@link sendSingleChunk}, [`sendSourceAmount`]{@link sendSourceAmount}, and [`sendDestinationAmount`]{@link sendDestinationAmount}. */\nexport interface SendResult {\n  id: Buffer,\n  /** Integer amount that the sender sent. Denoted in the sender's currency and units. */\n  sourceAmount: string,\n  /** Integer amount that the receiver says they received. Denoted in the receiver's currency and units. */\n  destinationAmount: string,\n  /** The number of payment chunks that were sent successfully as part of this payment. */\n  chunksFulfilled: number,\n  /** The number of payment chunks that were rejected as part of this payment. */\n  chunksRejected: number\n}\n\n/** Parameters for sending a chunked payment with the **experimental** [`sendSourceAmount`]{@link sendSourceAmount} method */\nexport interface SendSourceParams {\n  /** Source amount that the sender will send. Denoted in the sender's currency and units. This may be split into multiple chunks. */\n  sourceAmount: BigNumber | string | number,\n  /** Shared secret from the Receiver (generated with the [`generateAddressAndSecret`]{@link Receiver.generateAddressAndSecret} method). */\n  sharedSecret: Buffer,\n  /** Destination account of the Receiver (generated with the [`generateAddressAndSecret`]{@link Receiver.generateAddressAndSecret} method). */\n  destinationAccount: string,\n  /** Optional ID that will be used as the PSK Payment ID. Defaults to a random 16-byte ID. */\n  id?: Buffer\n}\n\n/** Parameters for sending a chunked payment with the **experimental** [`sendDestinationAmount`]{@link sendDestinationAmount} method */\nexport interface SendDestinationParams {\n  /**\n   * Destination amount that will be delivered to the Receiver. Denoted in the receiver's currency and units.\n   *\n   * **Note:** The sender will keep sending payment chunks until the receiver says they have gotten this amount. This method SHOULD NOT be used with untrusted receivers.\n   */\n  destinationAmount: BigNumber | string | number,\n  /** Shared secret from the Receiver (generated with the [`generateAddressAndSecret`]{@link Receiver.generateAddressAndSecret} method). */\n  sharedSecret: Buffer,\n  /** Destination account of the Receiver (generated with the [`generateAddressAndSecret`]{@link Receiver.generateAddressAndSecret} method). */\n  destinationAccount: string,\n  /** Optional ID that will be used as the PSK Payment ID. Defaults to a random 16-byte ID. */\n  id?: Buffer\n}\n\n/**\n * Get an approximate quote for how much will be delivered to the Receiver if the sender sends the given source amount.\n *\n * The value returned is non-binding so the exchange rate may change after the quote is returned.\n *\n * **Note:** This method sends an unfulfillable test payment of the given amount to the Receiver to determine the path exchange rate.\n */\nexport async function quoteSourceAmount (plugin: PluginV2 | PluginV1, params: QuoteSourceParams) {\n  let {\n    sourceAmount,\n    sharedSecret,\n    destinationAccount,\n    id = crypto.randomBytes(16)\n  } = params\n  sourceAmount = new BigNumber(sourceAmount)\n  assert(sourceAmount.isInteger(), 'sourceAmount must be an integer')\n  assert(sharedSecret, 'sharedSecret is required')\n  assert(sharedSecret.length >= 32, 'sharedSecret must be at least 32 bytes')\n  /* tslint:disable-next-line:strict-type-predicates */\n  assert(destinationAccount && typeof destinationAccount === 'string', 'destinationAccount is required')\n  assert((Buffer.isBuffer(id) && id.length === 16), 'id must be a 16-byte buffer')\n  return quote(plugin, sharedSecret, id, destinationAccount, sourceAmount, undefined)\n}\n\n/**\n * Get an approximate quote for how much the sender must send in order to deliver the given destination amount to the Receiver.\n *\n * The value returned is non-binding so the exchange rate may change after the quote is returned.\n *\n * Currently, this method assumes exchange rates are linear. The result may be incorrect if the path exchange rate varies by size of payment.\n *\n * **Note:** This method sends an unfulfillable test payment of `1000` source units to the Receiver to determine the path exchange rate.\n */\nexport async function quoteDestinationAmount (plugin: PluginV2 | PluginV1, params: QuoteDestinationParams) {\n  let {\n    destinationAmount,\n    sharedSecret,\n    destinationAccount,\n    id = crypto.randomBytes(16)\n  } = params\n  destinationAmount = new BigNumber(destinationAmount)\n  assert(destinationAmount.isInteger(), 'destinationAmount must be an integer')\n  assert(sharedSecret, 'sharedSecret is required')\n  assert(sharedSecret.length >= 32, 'sharedSecret must be at least 32 bytes')\n  /* tslint:disable-next-line:strict-type-predicates */\n  assert(destinationAccount && typeof destinationAccount === 'string', 'destinationAccount is required')\n  assert((Buffer.isBuffer(id) && id.length === 16), 'id must be a 16-byte buffer if supplied')\n  return quote(plugin, sharedSecret, id, destinationAccount, undefined, destinationAmount)\n}\n\nasync function quote (\n  plugin: PluginV2 | PluginV1,\n  sharedSecret: Buffer,\n  id: Buffer,\n  destinationAccount: string,\n  sourceAmount?: BigNumber,\n  destinationAmount?: BigNumber\n): Promise<QuoteResult> {\n  plugin = convert(plugin)\n  const debug = Debug('ilp-protocol-psk2:quote')\n\n  const sequence = 0\n  const data = serializePskPacket(\n    sharedSecret, {\n      // TODO should this be the last chunk? what if you want to use the same id for the quote and payment?\n      type: constants.TYPE_PSK2_LAST_CHUNK,\n      paymentId: id,\n      sequence,\n      paymentAmount: constants.MAX_UINT64,\n      // Setting the chunk amount to the max will cause the receiver to\n      // reject the chunk (though we also make the condition unfulfillable\n      // to ensure that they cannot fulfill the chunk)\n      chunkAmount: constants.MAX_UINT64\n    })\n  const amount = new BigNumber(sourceAmount || STARTING_TRANSFER_AMOUNT).toString(10)\n  const ilp = IlpPacket.serializeIlpPrepare({\n    destination: destinationAccount,\n    amount,\n    executionCondition: crypto.randomBytes(32),\n    expiresAt: new Date(Date.now() + DEFAULT_TRANSFER_TIMEOUT),\n    data\n  })\n\n  let amountArrived = new BigNumber(0)\n  const result = await plugin.sendData(ilp)\n  let rejection\n  try {\n    rejection = IlpPacket.deserializeIlpReject(result)\n    assert(rejection.code === 'F99', `Got unexpected error code: ${rejection.code} ${rejection.message}`)\n    assert(rejection.data.length > 0, 'Got empty response data')\n  } catch (err) {\n    debug('error deserializing quote response:', err)\n    throw new Error('Error getting quote: ' + err.message)\n  }\n\n  try {\n    const quoteResponse = deserializePskPacket(sharedSecret, rejection.data)\n\n    // Validate that this is actually the response to our request\n    assert(quoteResponse.type === constants.TYPE_PSK2_ERROR, 'response type must be error')\n    assert(id.equals(quoteResponse.paymentId), 'response Payment ID does not match outgoing quote')\n    assert(sequence === quoteResponse.sequence, 'sequence does not match outgoing quote')\n\n    amountArrived = quoteResponse.chunkAmount\n  } catch (decryptionErr) {\n    debug('error parsing encrypted quote response', decryptionErr, result.toString('base64'))\n    throw new Error('unable to parse quote response')\n  }\n\n  debug(`receiver got: ${amountArrived.toString(10)} when sender sent: ${amount} (rate: ${amountArrived.div(amount).toString(10)})`)\n  let quotedSourceAmount\n  let quotedDestinationAmount\n  if (sourceAmount) {\n    quotedSourceAmount = new BigNumber(sourceAmount)\n    quotedDestinationAmount = amountArrived\n  } else {\n    quotedSourceAmount = new BigNumber(destinationAmount as BigNumber)\n      .div(amountArrived)\n      .times(STARTING_TRANSFER_AMOUNT)\n      .round(0, BigNumber.ROUND_UP)\n    // TODO should we always round up or just half up?\n    quotedDestinationAmount = new BigNumber(destinationAmount as BigNumber)\n  }\n  return {\n    sourceAmount: quotedSourceAmount.toString(10),\n    destinationAmount: quotedDestinationAmount.toString(10)\n  }\n}\n\n/**\n * Send a single payment chunk. This may be used for one-off payments or streaming payments.\n *\n * If this method is used for streaming payments, the user must pass in the [`SendSingleChunkAdvancedParams`]{@link SendSingleChunkAdvancedParams}.\n *\n * @example <caption>One-off payment</caption>\n * ```typescript\n *   import { sendSingleChunk, quoteDestinationAmount } from 'ilp-protocol-psk2'\n *\n *   // These values must be communicated beforehand for the sender to send a payment\n *   const { destinationAccount, sharedSecret } = await getAddressAndSecretFromReceiver()\n *\n *   const { sourceAmount } = await quoteDestinationAmount(myLedgerPlugin, {\n *     destinationAccount,\n *     sharedSecret,\n *     destinationAmount: '1000'\n *   })\n *\n *   const result = await sendSingleChunk(myLedgerPlugin, {\n *     destinationAccount,\n *     sharedSecret,\n *     sourceAmount,\n *     minDestinationAmount: '999'\n *   })\n *   console.log(`Sent payment of ${result.sourceAmount}, receiver got ${result.destinationAmount}`)\n * ```\n *\n * @example <caption>Streaming payments</caption>\n * ```typescript\n *   import { randomBytes } from 'crypto'\n *   import { sendSingleChunk } from 'ilp-protocol-psk2'\n *\n *   // These values must be communicated beforehand for the sender to send a payment\n *   const { destinationAccount, sharedSecret } = await getAddressAndSecretFromReceiver()\n *\n *   const id = randomBytes(16)\n *   let sequence = 0\n *   const firstChunkResult = await sendSingleChunk(myLedgerPlugin, {\n *     destinationAccount,\n *     sharedSecret,\n *     sourceAmount,\n *     minDestinationAmount: '0',\n *     id,\n *     sequence,\n *     lastChunk: false\n *   })\n *\n *  // Repeat as many times as desired, incrementing the sequence each time\n *  // Note that the path exchange rate can be determined by dividing the destination amount returned by the chunk amount sent\n *\n *   const lastChunkResult = await sendSingleChunk(myLedgerPlugin, {\n *     destinationAccount,\n *     sharedSecret,\n *     sourceAmount,\n *     minDestinationAmount: '0',\n *     id,\n *     sequence,\n *     lastChunk: true\n *   })\n * ```\n */\nexport async function sendSingleChunk (plugin: any, params: SendSingleChunkParams | SendSingleChunkAdvancedParams): Promise<SendResult> {\n  plugin = convert(plugin)\n  const debug = Debug('ilp-protocol-psk2:sendSingleChunk')\n  const {\n    sourceAmount,\n    sharedSecret,\n    destinationAccount,\n    minDestinationAmount = 0\n  } = params\n\n  function isAdvanced (params: SendSingleChunkParams | SendSingleChunkAdvancedParams): params is SendSingleChunkAdvancedParams {\n    /* tslint:disable-next-line */\n    return (params as SendSingleChunkAdvancedParams).id !== undefined\n  }\n  const {\n    id,\n    sequence,\n    lastChunk\n  } = (isAdvanced(params) ? params : {\n    // Defaults\n    id: crypto.randomBytes(16),\n    sequence: 0,\n    lastChunk: true\n  })\n\n  assert(sharedSecret, 'sharedSecret is required')\n  assert(sharedSecret.length >= 32, 'sharedSecret must be at least 32 bytes')\n  assert(sourceAmount, 'sourceAmount is required')\n  assert(!id || (Buffer.isBuffer(id) && id.length === 16), 'id must be a 16-byte buffer if supplied')\n\n  debug(`sending single chunk payment ${id.toString('hex')} with source amount: ${sourceAmount} and minimum destination amount: ${minDestinationAmount}`)\n\n  const data = serializePskPacket(sharedSecret, {\n    type: (lastChunk ? constants.TYPE_PSK2_LAST_CHUNK : constants.TYPE_PSK2_CHUNK),\n    paymentId: id,\n    sequence,\n    // We don't set the paymentAmount to the minDestinationAmount just in case\n    // we deliver slightly too much (for example because of rounding issues) and we\n    // don't want the receiver to reject the transfer because of this\n    paymentAmount: constants.MAX_UINT64,\n    chunkAmount: new BigNumber(minDestinationAmount)\n  })\n  const fulfillment = dataToFulfillment(sharedSecret, data)\n  const executionCondition = fulfillmentToCondition(fulfillment)\n  const ilp = IlpPacket.serializeIlpPrepare({\n    destination: destinationAccount,\n    amount: new BigNumber(sourceAmount).toString(10),\n    executionCondition,\n    expiresAt: new Date(Date.now() + DEFAULT_TRANSFER_TIMEOUT),\n    data\n  })\n\n  const result = await plugin.sendData(ilp)\n\n  let parsed\n  try {\n    parsed = IlpPacket.deserializeIlpPacket(result)\n  } catch (err) {\n    debug('error parsing sendData response:', err, 'response:', result.toString('base64'))\n    throw err\n  }\n\n  let fulfillmentInfo: IlpPacket.IlpFulfill\n  if (parsed.type === IlpPacket.Type.TYPE_ILP_FULFILL) {\n    /* tslint:disable-next-line:no-unnecessary-type-assertion */\n    fulfillmentInfo = parsed.data as IlpPacket.IlpFulfill\n  } else if (parsed.type === IlpPacket.Type.TYPE_ILP_REJECT) {\n    /* tslint:disable-next-line:no-unnecessary-type-assertion */\n    const rejection: IlpPacket.IlpRejection = parsed.data as IlpPacket.IlpRejection\n    // TODO throw specific error if the receiver says they received too little\n    // TODO use ILP error code string\n    debug('error sending payment:', JSON.stringify(rejection))\n    throw new Error(`Error sending payment. code: ${rejection.code}, message: ${rejection.message} `)\n  } else {\n    debug('sendData returned unexpected packet type:', JSON.stringify(parsed))\n    throw new Error('Unexpected type for sendData response: ' + parsed.type)\n  }\n\n  if (!fulfillment.equals(fulfillmentInfo.fulfillment)) {\n    debug(`Received invalid fulfillment. expected: ${fulfillment.toString('base64')}, actual: ${fulfillmentInfo.fulfillment.toString('base64')}`)\n    throw new Error(`Received invalid fulfillment. expected: ${fulfillment.toString('base64')}, actual: ${fulfillmentInfo.fulfillment.toString('base64')}`)\n  }\n\n  let amountArrived\n  try {\n    const response = deserializePskPacket(sharedSecret, fulfillmentInfo.data)\n\n    assert(constants.TYPE_PSK2_FULFILLMENT === response.type, `unexpected PSK packet type. expected: ${constants.TYPE_PSK2_FULFILLMENT}, actual: ${response.type}`)\n    assert(id.equals(response.paymentId), `response does not correspond to request. payment id does not match. actual: ${response.paymentId.toString('hex')}, expected: ${id.toString('hex')}`)\n    assert(sequence === response.sequence, `response does not correspond to request. sequence does not match. actual: ${response.sequence}, expected: ${sequence}`)\n\n    amountArrived = response.chunkAmount\n  } catch (err) {\n    debug('got invalid response:', err, JSON.stringify(result))\n    throw new Error('Invalid response from receiver: ' + err.message)\n  }\n\n  debug(`sent single chunk payment ${id.toString('hex')} with source amount: ${sourceAmount}, destination amount: ${amountArrived.toString(10)}`)\n\n  return {\n    // TODO should this be a buffer or string?\n    id,\n    sourceAmount: new BigNumber(sourceAmount).toString(10),\n    destinationAmount: amountArrived.toString(10),\n    chunksFulfilled: 1,\n    chunksRejected: 0\n  }\n}\n\n/**\n * **Experimental** method for sending a chunked payment with a fixed source amount.\n *\n * The sender will keep sending payment chunks until the given source amount has been sent.\n *\n * **Note:** Chunked payments may be interrupted in the middle, for example if the path runs out of liquidity. This method should be used with caution.\n */\nexport async function sendSourceAmount (plugin: any, params: SendSourceParams): Promise<SendResult> {\n  assert(params.sourceAmount, 'sourceAmount is required')\n  return sendChunkedPayment(plugin, params)\n}\n\n/**\n * **Experimental** method for sending a chunked payment with a fixed destination amount.\n *\n * The sender will keep sending payment chunks until the receiver says they have gotten the given destination amount. **This method SHOULD NOT be used with untrusted receivers.**\n *\n * **Note**: Chunked payments may be interrupted in the middle and the path exchange rate may change while a payment is being sent. **This method should be used with EXTREME CAUTION.**\n */\nexport async function sendDestinationAmount (plugin: any, params: SendDestinationParams): Promise<SendResult> {\n  // TODO allow setting a maximum source amount? (the problem would be that even if you hit the max, you still would have sent it without delivering the destination amount)\n  assert(params.destinationAmount, 'destinationAmount is required')\n  return sendChunkedPayment(plugin, params)\n}\n\ninterface ChunkedPaymentParams {\n  sharedSecret: Buffer,\n  destinationAccount: string,\n  sourceAmount?: BigNumber | string | number,\n  destinationAmount?: BigNumber | string | number,\n  id?: Buffer\n}\n// TODO accept user data also\nasync function sendChunkedPayment (plugin: any, params: ChunkedPaymentParams): Promise<SendResult> {\n  const {\n    sharedSecret,\n    destinationAccount,\n    sourceAmount,\n    destinationAmount,\n    id = crypto.randomBytes(16)\n  } = params\n  assert(sharedSecret, 'sharedSecret is required')\n  assert(sharedSecret.length >= 32, 'sharedSecret must be at least 32 bytes')\n  assert(destinationAccount, 'destinationAccount is required')\n  assert((Buffer.isBuffer(id) && id.length === 16), 'id must be a 16-byte buffer if supplied')\n  plugin = convert(plugin)\n  const debug = Debug('ilp-protocol-psk2:chunkedPayment')\n\n  if (!warnedUserAboutChunkedPayments) {\n    console.warn('WARNING: PSK2 Chunked Payments are experimental. Money can be lost if an error occurs mid-payment or if the exchange rate changes dramatically! This should not be used for payments that are significantly larger than the path\\'s Maximum Payment Size.')\n    warnedUserAboutChunkedPayments = true\n  }\n\n  let amountSent = new BigNumber(0)\n  let amountDelivered = new BigNumber(0)\n  let sequence = 0\n  let chunkSize = new BigNumber(STARTING_TRANSFER_AMOUNT)\n  let lastChunk = false\n  let timeToWait = 0\n  let rate = new BigNumber(0)\n  let chunksFulfilled = 0\n  let chunksRejected = 0\n\n  function handleReceiverResponse (encrypted: Buffer, expectedType: number, expectedSequence: number) {\n    try {\n      const response = deserializePskPacket(sharedSecret, encrypted)\n\n      assert(expectedType === response.type, `unexpected packet type. expected: ${expectedType}, actual: ${response.type}`)\n      assert(id.equals(response.paymentId), `response does not correspond to request. payment id does not match. actual: ${response.paymentId.toString('hex')}, expected: ${id.toString('hex')}`)\n      assert(expectedSequence === response.sequence, `response does not correspond to request. sequence does not match. actual: ${response.sequence}, expected: ${sequence - 1}`)\n\n      const amountReceived = response.paymentAmount\n      debug(`receiver says they have received: ${amountReceived.toString(10)}`)\n      if (amountReceived.gte(amountDelivered)) {\n        amountDelivered = amountReceived\n        rate = amountDelivered.div(amountSent)\n      } else {\n        // TODO should we throw a more serious error here?\n        debug(`receiver decreased the amount they say they received. previously: ${amountDelivered.toString(10)}, now: ${amountReceived.toString(10)}`)\n      }\n    } catch (err) {\n      debug('error decrypting response data:', err, encrypted.toString('base64'))\n      throw new Error('Got bad response from receiver: ' + err.message)\n    }\n  }\n\n  while (true) {\n    // Figure out if we've sent enough already\n    let amountLeftToSend\n    if (sourceAmount) {\n      // Fixed source amount\n      amountLeftToSend = new BigNumber(sourceAmount).minus(amountSent)\n      debug(`amount left to send: ${amountLeftToSend.toString(10)}`)\n    } else {\n      // Fixed destination amount\n      const amountLeftToDeliver = new BigNumber(destinationAmount || 0).minus(amountDelivered)\n      if (amountLeftToDeliver.lte(0)) {\n        debug('amount left to deliver: 0')\n        break\n      }\n      // Use the path exchange rate to figure out the amount left to send\n      if (amountSent.gt(0)) {\n        const rate = amountDelivered.div(amountSent)\n        amountLeftToSend = amountLeftToDeliver.div(rate).round(0, BigNumber.ROUND_CEIL) // round up\n        debug(`amount left to send: ${amountLeftToSend.toString(10)} (amount left to deliver: ${amountLeftToDeliver.toString(10)}, rate: ${rate.toString(10)})`)\n      } else {\n        // We don't know how much more we need to send\n        amountLeftToSend = constants.MAX_UINT64\n        debug('amount left to send: unknown')\n      }\n    }\n\n    // Stop if we've already sent enough\n    if (amountLeftToSend.lte(0)) {\n      break\n    }\n\n    // If there's only one more chunk to send, communicate that to the receiver\n    if (amountLeftToSend.lte(chunkSize)) {\n      debug('sending last chunk')\n      chunkSize = amountLeftToSend\n      lastChunk = true\n    }\n\n    // TODO should we allow the rate to fluctuate more?\n    const minimumAmountReceiverShouldAccept = BigNumber.min(\n      rate.times(chunkSize).round(0, BigNumber.ROUND_DOWN),\n      constants.MAX_UINT64)\n\n    const data = serializePskPacket(sharedSecret, {\n      type: (lastChunk ? constants.TYPE_PSK2_LAST_CHUNK : constants.TYPE_PSK2_CHUNK),\n      paymentId: id,\n      sequence,\n      paymentAmount: (destinationAmount ? new BigNumber(destinationAmount) : constants.MAX_UINT64),\n      chunkAmount: minimumAmountReceiverShouldAccept\n    })\n    const fulfillment = dataToFulfillment(sharedSecret, data)\n    const executionCondition = fulfillmentToCondition(fulfillment)\n    const prepare = IlpPacket.serializeIlpPrepare({\n      destination: destinationAccount,\n      amount: chunkSize.toString(10),\n      expiresAt: new Date(Date.now() + DEFAULT_TRANSFER_TIMEOUT),\n      executionCondition,\n      data\n    })\n\n    const result = await plugin.sendData(prepare)\n\n    let parsed\n    try {\n      parsed = IlpPacket.deserializeIlpPacket(result)\n    } catch (err) {\n      debug('error parsing sendData response:', err, 'response:', result.toString('base64'))\n      throw err\n    }\n\n    if (parsed.type === IlpPacket.Type.TYPE_ILP_FULFILL) {\n      /* tslint:disable-next-line:no-unnecessary-type-assertion */\n      const fulfill = parsed.data as IlpPacket.IlpFulfill\n\n      if (!fulfillment.equals(fulfill.fulfillment)) {\n        debug(`Received invalid fulfillment. expected: ${fulfillment.toString('base64')}, actual: ${fulfill.fulfillment.toString('base64')}`)\n        throw new Error(`Received invalid fulfillment. expected: ${fulfillment.toString('base64')}, actual: ${fulfill.fulfillment.toString('base64')}`)\n      }\n\n      amountSent = amountSent.plus(chunkSize)\n      handleReceiverResponse(fulfill.data, constants.TYPE_PSK2_FULFILLMENT, sequence)\n\n      chunksFulfilled += 1\n      chunkSize = chunkSize.times(TRANSFER_INCREASE).round(0)\n      debug('transfer was successful, increasing chunk size to:', chunkSize.toString(10))\n      timeToWait = 0\n\n      if (lastChunk) {\n        break\n      } else {\n        sequence++\n      }\n    } else if (parsed.type === IlpPacket.Type.TYPE_ILP_REJECT) {\n      /* tslint:disable-next-line:no-unnecessary-type-assertion */\n      const rejection = parsed.data as IlpPacket.IlpRejection\n      if (rejection.code === 'F99') {\n        // Handle if the receiver rejects the transfer with a PSK packet\n        handleReceiverResponse(\n          rejection.data,\n          constants.TYPE_PSK2_ERROR,\n          sequence)\n      } else if (rejection.code[0] === 'T' || rejection.code[0] === 'R') {\n        // Handle temporary and relative errors\n        // TODO is this the right behavior in this situation?\n        // TODO don't retry forever\n        chunkSize = chunkSize\n          .times(TRANSFER_DECREASE)\n          .round(0)\n        if (chunkSize.lt(1)) {\n          chunkSize = new BigNumber(1)\n        }\n        timeToWait = Math.max(timeToWait * 2, 100)\n        debug(`got temporary ILP rejection: ${rejection.code}, reducing chunk size to: ${chunkSize.toString(10)} and waiting: ${timeToWait}ms`)\n        await new Promise((resolve, reject) => setTimeout(resolve, timeToWait))\n      } else {\n        // TODO is it ever worth retrying here?\n        debug('got ILP rejection with final error:', JSON.stringify(rejection))\n        throw new Error(`Transfer rejected with final error: ${rejection.code}${(rejection.message ? ': ' + rejection.message : '')}`)\n      }\n    } else {\n      debug('sendData returned unexpected packet type:', JSON.stringify(parsed))\n      throw new Error('Unexpected type for sendData response: ' + parsed.type)\n    }\n  }\n\n  debug(`sent payment. source amount: ${amountSent.toString(10)}, destination amount: ${amountDelivered.toString(10)}, number of chunks: ${sequence + 1}`)\n\n  return {\n    id,\n    sourceAmount: amountSent.toString(10),\n    destinationAmount: amountDelivered.toString(10),\n    chunksFulfilled,\n    chunksRejected\n  }\n}\n"]}