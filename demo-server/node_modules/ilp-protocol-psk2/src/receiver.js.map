{"version":3,"file":"receiver.js","sourceRoot":"","sources":["receiver.ts"],"names":[],"mappings":"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","sourcesContent":["'use strict'\n\nimport * as assert from 'assert'\nimport * as crypto from 'crypto'\nimport * as Debug from 'debug'\nconst debug = Debug('ilp-protocol-psk2:receiver')\nimport BigNumber from 'bignumber.js'\nimport { default as convertToV2Plugin, PluginV1, PluginV2 } from 'ilp-compat-plugin'\nimport IlpPacket = require('ilp-packet')\nimport * as constants from './constants'\nimport { serializePskPacket, deserializePskPacket, PskPacket } from './encoding'\nimport { dataToFulfillment, fulfillmentToCondition } from './condition'\nimport * as ILDCP from 'ilp-protocol-ildcp'\n\nconst RECEIVER_ID_STRING = 'ilp_psk2_receiver_id'\nconst PSK_GENERATION_STRING = 'ilp_psk2_generation'\nconst RECEIVER_ID_LENGTH = 8\nconst TOKEN_LENGTH = 18\nconst SHARED_SECRET_LENGTH = 32\n\n/**\n * Review callback that will be called every time the Receiver receives an incoming payment or payment chunk.\n *\n * The payment handler can call the [`accept`]{@link PaymentHandlerParams.accept} or [`reject`]{@link PaymentHandlerParams.reject} methods to fulfill or reject the entire payment.\n */\nexport interface PaymentHandler {\n  (params: PaymentHandlerParams): void | Promise<void>\n}\n\n/**\n * Parameters passed to the Receiver's payment handler callback.\n */\nexport interface PaymentHandlerParams {\n  id: Buffer,\n  /** Total amount that should be delivered by this payment.\n   * If the sender has not specified a destination amount, this value will be the maximum UInt64 value or 18446744073709551615.\n   */\n  expectedAmount: string,\n  /**\n   * Accept the entire payment.\n   * The Receiver will automatically fulfill all incoming chunks until the `expectedAmount`\n   * has been delivered or the sender has indicated the payment is finished.\n   *\n   * The Promise returned will resolve to a [`PaymentReceived`]{@link PaymentReceived} when the payment is finished.\n   */\n  accept: () => Promise<PaymentReceived>,\n  /**\n   * Reject the entire payment (and all subsequent chunks with the same `id`).\n   */\n  reject: (message: string) => void,\n  /**\n   * Alternative to `accept` that gives the user more control over the payment chunks they wish to fulfill.\n   * If this method is called, the PaymentHandler callback will be called again for subsequent chunks with the same payment `id`.\n   */\n  acceptSingleChunk: () => void,\n  /**\n   * Alternative to `reject` that gives the user more control over the payment chunks they wish to reject.\n   * If this method is called, the PaymentHandler callback will be called again for subsequent chunks with the same payment `id`.\n   */\n  rejectSingleChunk: (message: string) => void,\n  /**\n   * Details about this prepared chunk; in the form of a parsed interledger packet.\n   */\n  prepare: IlpPacket.IlpPrepare\n}\n\nexport interface PaymentReceived {\n  id: Buffer,\n  receivedAmount: string,\n  expectedAmount: string,\n  chunksFulfilled: number\n}\n\n/**\n * Params for instantiating a Receiver using the [`createReceiver`]{@link createReceiver} function.\n */\nexport interface ReceiverOpts {\n  plugin: PluginV2 | PluginV1,\n  paymentHandler: PaymentHandler,\n  secret?: Buffer\n}\n\n/**\n * PSK2 Receiver class that listens for and accepts incoming payments.\n *\n * The same Receiver may be used for accepting single-chunk payments, streaming payments, and chunked payments.\n *\n * It is recommended to use the [`createReceiver`]{@link createReceiver} function to instantiate Receivers.\n */\nexport class Receiver {\n  protected plugin: PluginV2\n  protected secret: Buffer\n  protected receiverId: string\n  protected paymentHandler: PaymentHandler\n  protected address: string\n  protected payments: Object\n  protected connected: boolean\n\n  constructor (plugin: PluginV2 | PluginV1, secret: Buffer) {\n    this.plugin = convertToV2Plugin(plugin)\n    assert(secret.length >= 32, 'secret must be at least 32 bytes')\n    this.secret = secret\n    // TODO is the receiver ID necessary if ILDCP will return different addresses for each listener?\n    this.receiverId = getReceiverId(this.secret)\n    this.paymentHandler = this.defaultPaymentHandler\n    this.address = ''\n    this.payments = {}\n    this.connected = false\n  }\n\n  /**\n   * Fetch the receiver's ILP address using [ILDCP](https://github.com/interledgerjs/ilp-protocol-ildcp) and listen for incoming payments.\n   */\n  async connect (): Promise<void> {\n    debug('connect called')\n    await this.plugin.connect()\n    // TODO refetch address if we're connected for long enough\n    this.address = (await ILDCP.fetch(this.plugin.sendData.bind(this.plugin))).clientAddress\n    this.plugin.registerDataHandler(this.handleData)\n    this.connected = true\n    debug('connected')\n  }\n\n  /**\n   * Stop listening for incoming payments.\n   */\n  async disconnect (): Promise<void> {\n    debug('disconnect called')\n    this.connected = false\n    this.plugin.deregisterDataHandler()\n    await this.plugin.disconnect()\n    debug('disconnected')\n  }\n\n  /**\n   * Check if the receiver is currently listening for incoming payments.\n   */\n  isConnected (): boolean {\n    this.connected = this.connected && this.plugin.isConnected()\n    return this.connected\n  }\n\n  /**\n   * Register a callback that will be called every time a new payment is received.\n   *\n   * The user must call `accept` or `acceptSingleChunk` to make the Receiver fulfill the payment.\n   */\n  registerPaymentHandler (handler: PaymentHandler): void {\n    debug('registered payment handler')\n    /* tslint:disable-next-line:strict-type-predicates */\n    assert(typeof handler === 'function', 'payment handler must be a function')\n    this.paymentHandler = handler\n  }\n\n  /**\n   * Remove the payment handler callback.\n   */\n  deregisterPaymentHandler (): void {\n    this.paymentHandler = this.defaultPaymentHandler\n  }\n\n  /**\n   * Generate a unique ILP address and shared secret to give to a sender.\n   *\n   * The Receiver must be connected before this method can be called.\n   *\n   * **Note:** A single shared secret MUST NOT be given to more than one sender.\n   */\n  generateAddressAndSecret (): { destinationAccount: string, sharedSecret: Buffer } {\n    assert(this.connected, 'Receiver must be connected')\n    const token = crypto.randomBytes(TOKEN_LENGTH)\n    return {\n      sharedSecret: generateSharedSecret(this.secret, token),\n      destinationAccount: `${this.address}.${this.receiverId}.${base64url(token)}`\n    }\n  }\n\n  protected async defaultPaymentHandler (params: PaymentHandlerParams): Promise<void> {\n    debug(`Receiver has no handler registered, rejecting payment ${params.id.toString('hex')}`)\n    return params.reject('Receiver has no payment handler registered')\n  }\n\n  protected reject (code: string, message?: string, data?: Buffer) {\n    return IlpPacket.serializeIlpReject({\n      code,\n      message: message || '',\n      data: data || Buffer.alloc(0),\n      triggeredBy: this.address\n    })\n  }\n\n  // This is an arrow function so we don't need to use bind when setting it on the plugin\n  protected handleData = async (data: Buffer): Promise<Buffer> => {\n    let prepare: IlpPacket.IlpPrepare\n    let sharedSecret: Buffer\n\n    try {\n      prepare = IlpPacket.deserializeIlpPrepare(data)\n      const parsedAccount = parseAccount(prepare.destination)\n\n      assert(parsedAccount.receiverId === this.receiverId, 'payment is for a different receiver')\n\n      sharedSecret = generateSharedSecret(this.secret, parsedAccount.token)\n    } catch (err) {\n      debug('error parsing incoming prepare:', err)\n      return this.reject('F06', 'Payment is not for this receiver')\n    }\n\n    let request: PskPacket\n    try {\n      request = deserializePskPacket(sharedSecret, prepare.data)\n    } catch (err) {\n      debug('error decrypting data:', err)\n      return this.reject('F06', 'Unable to parse data')\n    }\n\n    if (request.type !== constants.TYPE_PSK2_CHUNK && request.type !== constants.TYPE_PSK2_LAST_CHUNK) {\n      debug(`got unexpected request type: ${request.type}`)\n      // TODO should this be a different error code?\n      // (this might be a sign that they're using a different version of the protocol)\n      // TODO should this type of response be encrypted?\n      return this.reject('F06', 'Unexpected request type')\n    }\n\n    const paymentId = request.paymentId.toString('hex')\n    let record = this.payments[paymentId]\n    if (!record) {\n      record = {\n        // TODO buffer user data and keep track of sequence numbers\n        received: new BigNumber(0),\n        expected: new BigNumber(0),\n        finished: false,\n        finishedPromise: null,\n        acceptedByReceiver: null,\n        rejectionMessage: 'rejected by receiver',\n        chunksFulfilled: 0,\n        chunksRejected: 0 // doesn't include chunks we cannot parse\n      }\n      this.payments[paymentId] = record\n    }\n    record.expected = request.paymentAmount\n\n    const rejectTransfer = (message: string) => {\n      debug(`rejecting transfer ${request.sequence} of payment ${paymentId}: ${message}`)\n      record.chunksRejected += 1\n      const data = serializePskPacket(sharedSecret, {\n        type: constants.TYPE_PSK2_ERROR,\n        paymentId: request.paymentId,\n        sequence: request.sequence,\n        paymentAmount: record.received,\n        chunkAmount: new BigNumber(prepare.amount)\n      })\n      return this.reject('F99', '', data)\n    }\n\n    // Transfer amount too low\n    if (request.chunkAmount.gt(prepare.amount)) {\n      return rejectTransfer(`incoming transfer amount too low. actual: ${prepare.amount}, expected: ${request.chunkAmount.toString(10)}`)\n    }\n\n    // Payment is already finished\n    if (record.finished) {\n      // TODO should this return an F99 or something else?\n      return rejectTransfer(`payment is already finished`)\n    }\n\n    // TODO should we reject an incoming chunk if it would put us too far over the expected amount?\n\n    // Check if we can regenerate the correct fulfillment\n    let fulfillment\n    try {\n      fulfillment = dataToFulfillment(sharedSecret, prepare.data)\n      const generatedCondition = fulfillmentToCondition(fulfillment)\n      assert(generatedCondition.equals(prepare.executionCondition), `condition generated does not match. expected: ${prepare.executionCondition.toString('base64')}, actual: ${generatedCondition.toString('base64')}`)\n    } catch (err) {\n      debug('error regenerating fulfillment:', err)\n      record.chunksRejected += 1\n      return this.reject('F05', 'condition generated does not match prepare')\n    }\n\n    // Check if the receiver wants to accept the payment\n    let chunkAccepted = !!record.acceptedByReceiver\n    let userCalledAcceptOrReject = false\n    if (record.acceptedByReceiver === null) {\n      // This promise resolves when the user has either accepted or rejected the payment\n      await new Promise(async (resolve, reject) => {\n        // Reject the payment if:\n        // a) the user explicity calls reject\n        // b) if they don't call accept\n        // c) if there is an error thrown in the payment handler\n        try {\n          await Promise.resolve(this.paymentHandler({\n            // TODO include first chunk data\n            id: request.paymentId,\n            expectedAmount: record.expected.toString(10),\n            accept: async (): Promise<PaymentReceived> => {\n              userCalledAcceptOrReject = true\n              // Resolve the above promise so that we actually fulfill the incoming chunk\n              record.acceptedByReceiver = true\n              chunkAccepted = true\n              resolve()\n\n              // The promise returned to the receiver will be fulfilled\n              // when the whole payment is finished\n              const payment = await new Promise((resolve, reject) => {\n                record.finishedPromise = { resolve, reject }\n                // TODO should the payment timeout after some time?\n              }) as PaymentReceived\n\n              return payment\n            },\n            reject: (message: string) => {\n              userCalledAcceptOrReject = true\n              debug('receiver rejected payment with message:', message)\n              record.acceptedByReceiver = false\n              record.rejectionMessage = message\n              record.finished = false\n              // TODO check that the message isn't too long\n            },\n            // TODO throw error if you've waited too long and it's expired\n            acceptSingleChunk: (): void => {\n              userCalledAcceptOrReject = true\n              chunkAccepted = true\n              record.acceptedByReceiver = null\n              resolve()\n            },\n            rejectSingleChunk: (message: string) => {\n              userCalledAcceptOrReject = true\n              chunkAccepted = false\n              record.acceptedByReceiver = null\n              record.rejectionMessage = message\n              resolve()\n              // TODO check that the message isn't too long\n            },\n            prepare\n          }))\n\n          // If the user didn't call the accept function, reject it\n          if (!userCalledAcceptOrReject) {\n            record.acceptedByReceiver = false\n            record.rejectionMessage = 'receiver did not accept the payment'\n            record.finished = true\n          }\n        } catch (err) {\n          debug('error thrown in payment handler:', err)\n          record.acceptedByReceiver = false\n          record.rejectionMessage = err && err.message\n        }\n        resolve()\n      })\n    }\n\n    // Reject the chunk if the receiver rejected the whole payment\n    if (record.acceptedByReceiver === false) {\n      debug(`rejecting chunk because payment ${paymentId} was rejected by receiver with message: ${record.rejectionMessage}`)\n      record.chunksRejected += 1\n      return this.reject('F99', record.rejectionMessage)\n    }\n\n    // Reject the chunk of the receiver rejected the specific chunk\n    if (!chunkAccepted) {\n      debug(`rejecting chunk ${request.sequence} of payment ${paymentId} because it was rejected by the receiver with the message: ${record.rejectionMessage}`)\n      record.chunksRejected += 1\n      return this.reject('F99', record.rejectionMessage)\n    }\n\n    // Update stats based on that chunk\n    record.chunksFulfilled += 1\n    record.received = record.received.plus(prepare.amount)\n    if (record.received.gte(record.expected) || request.type === constants.TYPE_PSK2_LAST_CHUNK) {\n      record.finished = true\n      record.finishedPromise && record.finishedPromise.resolve({\n        id: request.paymentId,\n        receivedAmount: record.received.toString(10),\n        expectedAmount: record.expected.toString(10),\n        chunksFulfilled: record.chunksFulfilled,\n        chunksRejected: record.chunksRejected\n        // TODO add data\n      })\n    }\n\n    debug(`got ${record.finished ? 'last ' : ''}chunk of amount ${prepare.amount} for payment: ${paymentId}. total received: ${record.received.toString(10)}`)\n\n    // Let the sender know how much has arrived\n    const response = serializePskPacket(sharedSecret, {\n      type: constants.TYPE_PSK2_FULFILLMENT,\n      paymentId: request.paymentId,\n      sequence: request.sequence,\n      paymentAmount: record.received,\n      chunkAmount: new BigNumber(prepare.amount)\n    })\n\n    debug(`fulfilling transfer ${request.sequence} for payment ${paymentId} with fulfillment: ${fulfillment.toString('base64')}`)\n\n    return IlpPacket.serializeIlpFulfill({\n      fulfillment,\n      data: response\n    })\n  }\n}\n\n/**\n * Convenience function for instantiating and connecting a PSK2 [Receiver]{@link Receiver}.\n *\n * @example <caption>Creating a Receiver</caption>\n * ```typescript\n * import { createReceiver } from 'ilp-protocol-psk2'\n * const receiver = await createReceiver({\n *   plugin: myLedgerPlugin,\n *   paymentHandler: async (params) => {\n *     // Accept all incoming payments\n *     const result = await params.accept()\n *     console.log('Got payment for:', result.receivedAmount)\n *   }\n * })\n *\n * const { destinationAccount, sharedSecret } = receiver.generateAddressAndSecret()\n * // Give these two values to a sender to enable them to send payments to this Receiver\n * ```\n */\nexport async function createReceiver (opts: ReceiverOpts): Promise<Receiver> {\n  const {\n    plugin,\n    paymentHandler,\n    secret = crypto.randomBytes(32)\n  } = opts\n  const receiver = new Receiver(plugin, secret)\n  receiver.registerPaymentHandler(paymentHandler)\n  await receiver.connect()\n  return receiver\n}\n\nfunction parseAccount (destinationAccount: string): { destinationAccount: string, receiverId: string, token: Buffer } {\n  const split = destinationAccount.split('.')\n  assert(split.length >= 2, 'account must have receiverId and token components')\n  const receiverId = split[split.length - 2]\n  const token = Buffer.from(split[split.length - 1], 'base64')\n  return {\n    destinationAccount: split.slice(0, split.length - 2).join('.'),\n    receiverId,\n    token\n  }\n}\n\nfunction getReceiverId (secret: Buffer): string {\n  const buf = hmac(secret, Buffer.from(RECEIVER_ID_STRING, 'utf8')).slice(0, RECEIVER_ID_LENGTH)\n  return base64url(buf)\n}\n\nfunction generateSharedSecret (secret: Buffer, token: Buffer): Buffer {\n  const sharedSecretGenerator = hmac(secret, Buffer.from(PSK_GENERATION_STRING, 'utf8'))\n  return hmac(sharedSecretGenerator, token).slice(0, SHARED_SECRET_LENGTH)\n}\n\nfunction hmac (key: Buffer, message: Buffer): Buffer {\n  const h = crypto.createHmac('sha256', key)\n  h.update(message)\n  return h.digest()\n}\n\nfunction base64url (buf: Buffer): string {\n  return buf.toString('base64')\n    .replace(/=+$/, '')\n    .replace(/\\+/g, '-')\n    .replace(/\\//g, '_')\n}\n"]}