"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const crypto = require("crypto");
const Debug = require("debug");
const bignumber_js_1 = require("bignumber.js");
const IlpPacket = require("ilp-packet");
const ilp_compat_plugin_1 = require("ilp-compat-plugin");
const constants = require("./constants");
const encoding_1 = require("./encoding");
const condition_1 = require("./condition");
const DEFAULT_TRANSFER_TIMEOUT = 30000;
const STARTING_TRANSFER_AMOUNT = 1000;
const TRANSFER_INCREASE = 1.1;
const TRANSFER_DECREASE = 0.5;
let warnedUserAboutChunkedPayments = false;
function quoteSourceAmount(plugin, params) {
    return __awaiter(this, void 0, void 0, function* () {
        let { sourceAmount, sharedSecret, destinationAccount, id = crypto.randomBytes(16) } = params;
        sourceAmount = new bignumber_js_1.default(sourceAmount);
        assert(sourceAmount.isInteger(), 'sourceAmount must be an integer');
        assert(sharedSecret, 'sharedSecret is required');
        assert(sharedSecret.length >= 32, 'sharedSecret must be at least 32 bytes');
        assert(destinationAccount && typeof destinationAccount === 'string', 'destinationAccount is required');
        assert((Buffer.isBuffer(id) && id.length === 16), 'id must be a 16-byte buffer');
        return quote(plugin, sharedSecret, id, destinationAccount, sourceAmount, undefined);
    });
}
exports.quoteSourceAmount = quoteSourceAmount;
function quoteDestinationAmount(plugin, params) {
    return __awaiter(this, void 0, void 0, function* () {
        let { destinationAmount, sharedSecret, destinationAccount, id = crypto.randomBytes(16) } = params;
        destinationAmount = new bignumber_js_1.default(destinationAmount);
        assert(destinationAmount.isInteger(), 'destinationAmount must be an integer');
        assert(sharedSecret, 'sharedSecret is required');
        assert(sharedSecret.length >= 32, 'sharedSecret must be at least 32 bytes');
        assert(destinationAccount && typeof destinationAccount === 'string', 'destinationAccount is required');
        assert((Buffer.isBuffer(id) && id.length === 16), 'id must be a 16-byte buffer if supplied');
        return quote(plugin, sharedSecret, id, destinationAccount, undefined, destinationAmount);
    });
}
exports.quoteDestinationAmount = quoteDestinationAmount;
function quote(plugin, sharedSecret, id, destinationAccount, sourceAmount, destinationAmount) {
    return __awaiter(this, void 0, void 0, function* () {
        plugin = ilp_compat_plugin_1.default(plugin);
        const debug = Debug('ilp-protocol-psk2:quote');
        const sequence = 0;
        const data = encoding_1.serializePskPacket(sharedSecret, {
            type: constants.TYPE_PSK2_LAST_CHUNK,
            paymentId: id,
            sequence,
            paymentAmount: constants.MAX_UINT64,
            chunkAmount: constants.MAX_UINT64
        });
        const amount = new bignumber_js_1.default(sourceAmount || STARTING_TRANSFER_AMOUNT).toString(10);
        const ilp = IlpPacket.serializeIlpPrepare({
            destination: destinationAccount,
            amount,
            executionCondition: crypto.randomBytes(32),
            expiresAt: new Date(Date.now() + DEFAULT_TRANSFER_TIMEOUT),
            data
        });
        let amountArrived = new bignumber_js_1.default(0);
        const result = yield plugin.sendData(ilp);
        let rejection;
        try {
            rejection = IlpPacket.deserializeIlpReject(result);
            assert(rejection.code === 'F99', `Got unexpected error code: ${rejection.code} ${rejection.message}`);
            assert(rejection.data.length > 0, 'Got empty response data');
        }
        catch (err) {
            debug('error deserializing quote response:', err);
            throw new Error('Error getting quote: ' + err.message);
        }
        try {
            const quoteResponse = encoding_1.deserializePskPacket(sharedSecret, rejection.data);
            assert(quoteResponse.type === constants.TYPE_PSK2_ERROR, 'response type must be error');
            assert(id.equals(quoteResponse.paymentId), 'response Payment ID does not match outgoing quote');
            assert(sequence === quoteResponse.sequence, 'sequence does not match outgoing quote');
            amountArrived = quoteResponse.chunkAmount;
        }
        catch (decryptionErr) {
            debug('error parsing encrypted quote response', decryptionErr, result.toString('base64'));
            throw new Error('unable to parse quote response');
        }
        debug(`receiver got: ${amountArrived.toString(10)} when sender sent: ${amount} (rate: ${amountArrived.div(amount).toString(10)})`);
        let quotedSourceAmount;
        let quotedDestinationAmount;
        if (sourceAmount) {
            quotedSourceAmount = new bignumber_js_1.default(sourceAmount);
            quotedDestinationAmount = amountArrived;
        }
        else {
            quotedSourceAmount = new bignumber_js_1.default(destinationAmount)
                .div(amountArrived)
                .times(STARTING_TRANSFER_AMOUNT)
                .round(0, bignumber_js_1.default.ROUND_UP);
            quotedDestinationAmount = new bignumber_js_1.default(destinationAmount);
        }
        return {
            sourceAmount: quotedSourceAmount.toString(10),
            destinationAmount: quotedDestinationAmount.toString(10)
        };
    });
}
function sendSingleChunk(plugin, params) {
    return __awaiter(this, void 0, void 0, function* () {
        plugin = ilp_compat_plugin_1.default(plugin);
        const debug = Debug('ilp-protocol-psk2:sendSingleChunk');
        const { sourceAmount, sharedSecret, destinationAccount, minDestinationAmount = 0 } = params;
        function isAdvanced(params) {
            return params.id !== undefined;
        }
        const { id, sequence, lastChunk } = (isAdvanced(params) ? params : {
            id: crypto.randomBytes(16),
            sequence: 0,
            lastChunk: true
        });
        assert(sharedSecret, 'sharedSecret is required');
        assert(sharedSecret.length >= 32, 'sharedSecret must be at least 32 bytes');
        assert(sourceAmount, 'sourceAmount is required');
        assert(!id || (Buffer.isBuffer(id) && id.length === 16), 'id must be a 16-byte buffer if supplied');
        debug(`sending single chunk payment ${id.toString('hex')} with source amount: ${sourceAmount} and minimum destination amount: ${minDestinationAmount}`);
        const data = encoding_1.serializePskPacket(sharedSecret, {
            type: (lastChunk ? constants.TYPE_PSK2_LAST_CHUNK : constants.TYPE_PSK2_CHUNK),
            paymentId: id,
            sequence,
            paymentAmount: constants.MAX_UINT64,
            chunkAmount: new bignumber_js_1.default(minDestinationAmount)
        });
        const fulfillment = condition_1.dataToFulfillment(sharedSecret, data);
        const executionCondition = condition_1.fulfillmentToCondition(fulfillment);
        const ilp = IlpPacket.serializeIlpPrepare({
            destination: destinationAccount,
            amount: new bignumber_js_1.default(sourceAmount).toString(10),
            executionCondition,
            expiresAt: new Date(Date.now() + DEFAULT_TRANSFER_TIMEOUT),
            data
        });
        const result = yield plugin.sendData(ilp);
        let parsed;
        try {
            parsed = IlpPacket.deserializeIlpPacket(result);
        }
        catch (err) {
            debug('error parsing sendData response:', err, 'response:', result.toString('base64'));
            throw err;
        }
        let fulfillmentInfo;
        if (parsed.type === IlpPacket.Type.TYPE_ILP_FULFILL) {
            fulfillmentInfo = parsed.data;
        }
        else if (parsed.type === IlpPacket.Type.TYPE_ILP_REJECT) {
            const rejection = parsed.data;
            debug('error sending payment:', JSON.stringify(rejection));
            throw new Error(`Error sending payment. code: ${rejection.code}, message: ${rejection.message} `);
        }
        else {
            debug('sendData returned unexpected packet type:', JSON.stringify(parsed));
            throw new Error('Unexpected type for sendData response: ' + parsed.type);
        }
        if (!fulfillment.equals(fulfillmentInfo.fulfillment)) {
            debug(`Received invalid fulfillment. expected: ${fulfillment.toString('base64')}, actual: ${fulfillmentInfo.fulfillment.toString('base64')}`);
            throw new Error(`Received invalid fulfillment. expected: ${fulfillment.toString('base64')}, actual: ${fulfillmentInfo.fulfillment.toString('base64')}`);
        }
        let amountArrived;
        try {
            const response = encoding_1.deserializePskPacket(sharedSecret, fulfillmentInfo.data);
            assert(constants.TYPE_PSK2_FULFILLMENT === response.type, `unexpected PSK packet type. expected: ${constants.TYPE_PSK2_FULFILLMENT}, actual: ${response.type}`);
            assert(id.equals(response.paymentId), `response does not correspond to request. payment id does not match. actual: ${response.paymentId.toString('hex')}, expected: ${id.toString('hex')}`);
            assert(sequence === response.sequence, `response does not correspond to request. sequence does not match. actual: ${response.sequence}, expected: ${sequence}`);
            amountArrived = response.chunkAmount;
        }
        catch (err) {
            debug('got invalid response:', err, JSON.stringify(result));
            throw new Error('Invalid response from receiver: ' + err.message);
        }
        debug(`sent single chunk payment ${id.toString('hex')} with source amount: ${sourceAmount}, destination amount: ${amountArrived.toString(10)}`);
        return {
            id,
            sourceAmount: new bignumber_js_1.default(sourceAmount).toString(10),
            destinationAmount: amountArrived.toString(10),
            chunksFulfilled: 1,
            chunksRejected: 0
        };
    });
}
exports.sendSingleChunk = sendSingleChunk;
function sendSourceAmount(plugin, params) {
    return __awaiter(this, void 0, void 0, function* () {
        assert(params.sourceAmount, 'sourceAmount is required');
        return sendChunkedPayment(plugin, params);
    });
}
exports.sendSourceAmount = sendSourceAmount;
function sendDestinationAmount(plugin, params) {
    return __awaiter(this, void 0, void 0, function* () {
        assert(params.destinationAmount, 'destinationAmount is required');
        return sendChunkedPayment(plugin, params);
    });
}
exports.sendDestinationAmount = sendDestinationAmount;
function sendChunkedPayment(plugin, params) {
    return __awaiter(this, void 0, void 0, function* () {
        const { sharedSecret, destinationAccount, sourceAmount, destinationAmount, id = crypto.randomBytes(16) } = params;
        assert(sharedSecret, 'sharedSecret is required');
        assert(sharedSecret.length >= 32, 'sharedSecret must be at least 32 bytes');
        assert(destinationAccount, 'destinationAccount is required');
        assert((Buffer.isBuffer(id) && id.length === 16), 'id must be a 16-byte buffer if supplied');
        plugin = ilp_compat_plugin_1.default(plugin);
        const debug = Debug('ilp-protocol-psk2:chunkedPayment');
        if (!warnedUserAboutChunkedPayments) {
            console.warn('WARNING: PSK2 Chunked Payments are experimental. Money can be lost if an error occurs mid-payment or if the exchange rate changes dramatically! This should not be used for payments that are significantly larger than the path\'s Maximum Payment Size.');
            warnedUserAboutChunkedPayments = true;
        }
        let amountSent = new bignumber_js_1.default(0);
        let amountDelivered = new bignumber_js_1.default(0);
        let sequence = 0;
        let chunkSize = new bignumber_js_1.default(STARTING_TRANSFER_AMOUNT);
        let lastChunk = false;
        let timeToWait = 0;
        let rate = new bignumber_js_1.default(0);
        let chunksFulfilled = 0;
        let chunksRejected = 0;
        function handleReceiverResponse(encrypted, expectedType, expectedSequence) {
            try {
                const response = encoding_1.deserializePskPacket(sharedSecret, encrypted);
                assert(expectedType === response.type, `unexpected packet type. expected: ${expectedType}, actual: ${response.type}`);
                assert(id.equals(response.paymentId), `response does not correspond to request. payment id does not match. actual: ${response.paymentId.toString('hex')}, expected: ${id.toString('hex')}`);
                assert(expectedSequence === response.sequence, `response does not correspond to request. sequence does not match. actual: ${response.sequence}, expected: ${sequence - 1}`);
                const amountReceived = response.paymentAmount;
                debug(`receiver says they have received: ${amountReceived.toString(10)}`);
                if (amountReceived.gte(amountDelivered)) {
                    amountDelivered = amountReceived;
                    rate = amountDelivered.div(amountSent);
                }
                else {
                    debug(`receiver decreased the amount they say they received. previously: ${amountDelivered.toString(10)}, now: ${amountReceived.toString(10)}`);
                }
            }
            catch (err) {
                debug('error decrypting response data:', err, encrypted.toString('base64'));
                throw new Error('Got bad response from receiver: ' + err.message);
            }
        }
        while (true) {
            let amountLeftToSend;
            if (sourceAmount) {
                amountLeftToSend = new bignumber_js_1.default(sourceAmount).minus(amountSent);
                debug(`amount left to send: ${amountLeftToSend.toString(10)}`);
            }
            else {
                const amountLeftToDeliver = new bignumber_js_1.default(destinationAmount || 0).minus(amountDelivered);
                if (amountLeftToDeliver.lte(0)) {
                    debug('amount left to deliver: 0');
                    break;
                }
                if (amountSent.gt(0)) {
                    const rate = amountDelivered.div(amountSent);
                    amountLeftToSend = amountLeftToDeliver.div(rate).round(0, bignumber_js_1.default.ROUND_CEIL);
                    debug(`amount left to send: ${amountLeftToSend.toString(10)} (amount left to deliver: ${amountLeftToDeliver.toString(10)}, rate: ${rate.toString(10)})`);
                }
                else {
                    amountLeftToSend = constants.MAX_UINT64;
                    debug('amount left to send: unknown');
                }
            }
            if (amountLeftToSend.lte(0)) {
                break;
            }
            if (amountLeftToSend.lte(chunkSize)) {
                debug('sending last chunk');
                chunkSize = amountLeftToSend;
                lastChunk = true;
            }
            const minimumAmountReceiverShouldAccept = bignumber_js_1.default.min(rate.times(chunkSize).round(0, bignumber_js_1.default.ROUND_DOWN), constants.MAX_UINT64);
            const data = encoding_1.serializePskPacket(sharedSecret, {
                type: (lastChunk ? constants.TYPE_PSK2_LAST_CHUNK : constants.TYPE_PSK2_CHUNK),
                paymentId: id,
                sequence,
                paymentAmount: (destinationAmount ? new bignumber_js_1.default(destinationAmount) : constants.MAX_UINT64),
                chunkAmount: minimumAmountReceiverShouldAccept
            });
            const fulfillment = condition_1.dataToFulfillment(sharedSecret, data);
            const executionCondition = condition_1.fulfillmentToCondition(fulfillment);
            const prepare = IlpPacket.serializeIlpPrepare({
                destination: destinationAccount,
                amount: chunkSize.toString(10),
                expiresAt: new Date(Date.now() + DEFAULT_TRANSFER_TIMEOUT),
                executionCondition,
                data
            });
            const result = yield plugin.sendData(prepare);
            let parsed;
            try {
                parsed = IlpPacket.deserializeIlpPacket(result);
            }
            catch (err) {
                debug('error parsing sendData response:', err, 'response:', result.toString('base64'));
                throw err;
            }
            if (parsed.type === IlpPacket.Type.TYPE_ILP_FULFILL) {
                const fulfill = parsed.data;
                if (!fulfillment.equals(fulfill.fulfillment)) {
                    debug(`Received invalid fulfillment. expected: ${fulfillment.toString('base64')}, actual: ${fulfill.fulfillment.toString('base64')}`);
                    throw new Error(`Received invalid fulfillment. expected: ${fulfillment.toString('base64')}, actual: ${fulfill.fulfillment.toString('base64')}`);
                }
                amountSent = amountSent.plus(chunkSize);
                handleReceiverResponse(fulfill.data, constants.TYPE_PSK2_FULFILLMENT, sequence);
                chunksFulfilled += 1;
                chunkSize = chunkSize.times(TRANSFER_INCREASE).round(0);
                debug('transfer was successful, increasing chunk size to:', chunkSize.toString(10));
                timeToWait = 0;
                if (lastChunk) {
                    break;
                }
                else {
                    sequence++;
                }
            }
            else if (parsed.type === IlpPacket.Type.TYPE_ILP_REJECT) {
                const rejection = parsed.data;
                if (rejection.code === 'F99') {
                    handleReceiverResponse(rejection.data, constants.TYPE_PSK2_ERROR, sequence);
                }
                else if (rejection.code[0] === 'T' || rejection.code[0] === 'R') {
                    chunkSize = chunkSize
                        .times(TRANSFER_DECREASE)
                        .round(0);
                    if (chunkSize.lt(1)) {
                        chunkSize = new bignumber_js_1.default(1);
                    }
                    timeToWait = Math.max(timeToWait * 2, 100);
                    debug(`got temporary ILP rejection: ${rejection.code}, reducing chunk size to: ${chunkSize.toString(10)} and waiting: ${timeToWait}ms`);
                    yield new Promise((resolve, reject) => setTimeout(resolve, timeToWait));
                }
                else {
                    debug('got ILP rejection with final error:', JSON.stringify(rejection));
                    throw new Error(`Transfer rejected with final error: ${rejection.code}${(rejection.message ? ': ' + rejection.message : '')}`);
                }
            }
            else {
                debug('sendData returned unexpected packet type:', JSON.stringify(parsed));
                throw new Error('Unexpected type for sendData response: ' + parsed.type);
            }
        }
        debug(`sent payment. source amount: ${amountSent.toString(10)}, destination amount: ${amountDelivered.toString(10)}, number of chunks: ${sequence + 1}`);
        return {
            id,
            sourceAmount: amountSent.toString(10),
            destinationAmount: amountDelivered.toString(10),
            chunksFulfilled,
            chunksRejected
        };
    });
}
//# sourceMappingURL=sender.js.map