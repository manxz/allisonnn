'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const crypto = require("crypto");
const Debug = require("debug");
const debug = Debug('ilp-protocol-psk2:receiver');
const bignumber_js_1 = require("bignumber.js");
const ilp_compat_plugin_1 = require("ilp-compat-plugin");
const IlpPacket = require("ilp-packet");
const constants = require("./constants");
const encoding_1 = require("./encoding");
const condition_1 = require("./condition");
const ILDCP = require("ilp-protocol-ildcp");
const RECEIVER_ID_STRING = 'ilp_psk2_receiver_id';
const PSK_GENERATION_STRING = 'ilp_psk2_generation';
const RECEIVER_ID_LENGTH = 8;
const TOKEN_LENGTH = 18;
const SHARED_SECRET_LENGTH = 32;
class Receiver {
    constructor(plugin, secret) {
        this.handleData = (data) => __awaiter(this, void 0, void 0, function* () {
            let prepare;
            let sharedSecret;
            try {
                prepare = IlpPacket.deserializeIlpPrepare(data);
                const parsedAccount = parseAccount(prepare.destination);
                assert(parsedAccount.receiverId === this.receiverId, 'payment is for a different receiver');
                sharedSecret = generateSharedSecret(this.secret, parsedAccount.token);
            }
            catch (err) {
                debug('error parsing incoming prepare:', err);
                return this.reject('F06', 'Payment is not for this receiver');
            }
            let request;
            try {
                request = encoding_1.deserializePskPacket(sharedSecret, prepare.data);
            }
            catch (err) {
                debug('error decrypting data:', err);
                return this.reject('F06', 'Unable to parse data');
            }
            if (request.type !== constants.TYPE_PSK2_CHUNK && request.type !== constants.TYPE_PSK2_LAST_CHUNK) {
                debug(`got unexpected request type: ${request.type}`);
                return this.reject('F06', 'Unexpected request type');
            }
            const paymentId = request.paymentId.toString('hex');
            let record = this.payments[paymentId];
            if (!record) {
                record = {
                    received: new bignumber_js_1.default(0),
                    expected: new bignumber_js_1.default(0),
                    finished: false,
                    finishedPromise: null,
                    acceptedByReceiver: null,
                    rejectionMessage: 'rejected by receiver',
                    chunksFulfilled: 0,
                    chunksRejected: 0
                };
                this.payments[paymentId] = record;
            }
            record.expected = request.paymentAmount;
            const rejectTransfer = (message) => {
                debug(`rejecting transfer ${request.sequence} of payment ${paymentId}: ${message}`);
                record.chunksRejected += 1;
                const data = encoding_1.serializePskPacket(sharedSecret, {
                    type: constants.TYPE_PSK2_ERROR,
                    paymentId: request.paymentId,
                    sequence: request.sequence,
                    paymentAmount: record.received,
                    chunkAmount: new bignumber_js_1.default(prepare.amount)
                });
                return this.reject('F99', '', data);
            };
            if (request.chunkAmount.gt(prepare.amount)) {
                return rejectTransfer(`incoming transfer amount too low. actual: ${prepare.amount}, expected: ${request.chunkAmount.toString(10)}`);
            }
            if (record.finished) {
                return rejectTransfer(`payment is already finished`);
            }
            let fulfillment;
            try {
                fulfillment = condition_1.dataToFulfillment(sharedSecret, prepare.data);
                const generatedCondition = condition_1.fulfillmentToCondition(fulfillment);
                assert(generatedCondition.equals(prepare.executionCondition), `condition generated does not match. expected: ${prepare.executionCondition.toString('base64')}, actual: ${generatedCondition.toString('base64')}`);
            }
            catch (err) {
                debug('error regenerating fulfillment:', err);
                record.chunksRejected += 1;
                return this.reject('F05', 'condition generated does not match prepare');
            }
            let chunkAccepted = !!record.acceptedByReceiver;
            let userCalledAcceptOrReject = false;
            if (record.acceptedByReceiver === null) {
                yield new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                    try {
                        yield Promise.resolve(this.paymentHandler({
                            id: request.paymentId,
                            expectedAmount: record.expected.toString(10),
                            accept: () => __awaiter(this, void 0, void 0, function* () {
                                userCalledAcceptOrReject = true;
                                record.acceptedByReceiver = true;
                                chunkAccepted = true;
                                resolve();
                                const payment = yield new Promise((resolve, reject) => {
                                    record.finishedPromise = { resolve, reject };
                                });
                                return payment;
                            }),
                            reject: (message) => {
                                userCalledAcceptOrReject = true;
                                debug('receiver rejected payment with message:', message);
                                record.acceptedByReceiver = false;
                                record.rejectionMessage = message;
                                record.finished = false;
                            },
                            acceptSingleChunk: () => {
                                userCalledAcceptOrReject = true;
                                chunkAccepted = true;
                                record.acceptedByReceiver = null;
                                resolve();
                            },
                            rejectSingleChunk: (message) => {
                                userCalledAcceptOrReject = true;
                                chunkAccepted = false;
                                record.acceptedByReceiver = null;
                                record.rejectionMessage = message;
                                resolve();
                            },
                            prepare
                        }));
                        if (!userCalledAcceptOrReject) {
                            record.acceptedByReceiver = false;
                            record.rejectionMessage = 'receiver did not accept the payment';
                            record.finished = true;
                        }
                    }
                    catch (err) {
                        debug('error thrown in payment handler:', err);
                        record.acceptedByReceiver = false;
                        record.rejectionMessage = err && err.message;
                    }
                    resolve();
                }));
            }
            if (record.acceptedByReceiver === false) {
                debug(`rejecting chunk because payment ${paymentId} was rejected by receiver with message: ${record.rejectionMessage}`);
                record.chunksRejected += 1;
                return this.reject('F99', record.rejectionMessage);
            }
            if (!chunkAccepted) {
                debug(`rejecting chunk ${request.sequence} of payment ${paymentId} because it was rejected by the receiver with the message: ${record.rejectionMessage}`);
                record.chunksRejected += 1;
                return this.reject('F99', record.rejectionMessage);
            }
            record.chunksFulfilled += 1;
            record.received = record.received.plus(prepare.amount);
            if (record.received.gte(record.expected) || request.type === constants.TYPE_PSK2_LAST_CHUNK) {
                record.finished = true;
                record.finishedPromise && record.finishedPromise.resolve({
                    id: request.paymentId,
                    receivedAmount: record.received.toString(10),
                    expectedAmount: record.expected.toString(10),
                    chunksFulfilled: record.chunksFulfilled,
                    chunksRejected: record.chunksRejected
                });
            }
            debug(`got ${record.finished ? 'last ' : ''}chunk of amount ${prepare.amount} for payment: ${paymentId}. total received: ${record.received.toString(10)}`);
            const response = encoding_1.serializePskPacket(sharedSecret, {
                type: constants.TYPE_PSK2_FULFILLMENT,
                paymentId: request.paymentId,
                sequence: request.sequence,
                paymentAmount: record.received,
                chunkAmount: new bignumber_js_1.default(prepare.amount)
            });
            debug(`fulfilling transfer ${request.sequence} for payment ${paymentId} with fulfillment: ${fulfillment.toString('base64')}`);
            return IlpPacket.serializeIlpFulfill({
                fulfillment,
                data: response
            });
        });
        this.plugin = ilp_compat_plugin_1.default(plugin);
        assert(secret.length >= 32, 'secret must be at least 32 bytes');
        this.secret = secret;
        this.receiverId = getReceiverId(this.secret);
        this.paymentHandler = this.defaultPaymentHandler;
        this.address = '';
        this.payments = {};
        this.connected = false;
    }
    connect() {
        return __awaiter(this, void 0, void 0, function* () {
            debug('connect called');
            yield this.plugin.connect();
            this.address = (yield ILDCP.fetch(this.plugin.sendData.bind(this.plugin))).clientAddress;
            this.plugin.registerDataHandler(this.handleData);
            this.connected = true;
            debug('connected');
        });
    }
    disconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            debug('disconnect called');
            this.connected = false;
            this.plugin.deregisterDataHandler();
            yield this.plugin.disconnect();
            debug('disconnected');
        });
    }
    isConnected() {
        this.connected = this.connected && this.plugin.isConnected();
        return this.connected;
    }
    registerPaymentHandler(handler) {
        debug('registered payment handler');
        assert(typeof handler === 'function', 'payment handler must be a function');
        this.paymentHandler = handler;
    }
    deregisterPaymentHandler() {
        this.paymentHandler = this.defaultPaymentHandler;
    }
    generateAddressAndSecret() {
        assert(this.connected, 'Receiver must be connected');
        const token = crypto.randomBytes(TOKEN_LENGTH);
        return {
            sharedSecret: generateSharedSecret(this.secret, token),
            destinationAccount: `${this.address}.${this.receiverId}.${base64url(token)}`
        };
    }
    defaultPaymentHandler(params) {
        return __awaiter(this, void 0, void 0, function* () {
            debug(`Receiver has no handler registered, rejecting payment ${params.id.toString('hex')}`);
            return params.reject('Receiver has no payment handler registered');
        });
    }
    reject(code, message, data) {
        return IlpPacket.serializeIlpReject({
            code,
            message: message || '',
            data: data || Buffer.alloc(0),
            triggeredBy: this.address
        });
    }
}
exports.Receiver = Receiver;
function createReceiver(opts) {
    return __awaiter(this, void 0, void 0, function* () {
        const { plugin, paymentHandler, secret = crypto.randomBytes(32) } = opts;
        const receiver = new Receiver(plugin, secret);
        receiver.registerPaymentHandler(paymentHandler);
        yield receiver.connect();
        return receiver;
    });
}
exports.createReceiver = createReceiver;
function parseAccount(destinationAccount) {
    const split = destinationAccount.split('.');
    assert(split.length >= 2, 'account must have receiverId and token components');
    const receiverId = split[split.length - 2];
    const token = Buffer.from(split[split.length - 1], 'base64');
    return {
        destinationAccount: split.slice(0, split.length - 2).join('.'),
        receiverId,
        token
    };
}
function getReceiverId(secret) {
    const buf = hmac(secret, Buffer.from(RECEIVER_ID_STRING, 'utf8')).slice(0, RECEIVER_ID_LENGTH);
    return base64url(buf);
}
function generateSharedSecret(secret, token) {
    const sharedSecretGenerator = hmac(secret, Buffer.from(PSK_GENERATION_STRING, 'utf8'));
    return hmac(sharedSecretGenerator, token).slice(0, SHARED_SECRET_LENGTH);
}
function hmac(key, message) {
    const h = crypto.createHmac('sha256', key);
    h.update(message);
    return h.digest();
}
function base64url(buf) {
    return buf.toString('base64')
        .replace(/=+$/, '')
        .replace(/\+/g, '-')
        .replace(/\//g, '_');
}
//# sourceMappingURL=receiver.js.map